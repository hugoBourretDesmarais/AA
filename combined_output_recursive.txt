Documentation:

Advanced Text Generator Documentation
The Advanced Text Generator is Unity's newest text rendering module, employing Harfbuzz and ICU and FreeType to deliver comprehensive Unicode support and text shaping capabilities.
The integration of Harfbuzz and ICU significantly enhances text rendering capabilities. The system provides comprehensive support for OpenType and AAT (Apple Advanced Typography) Font Features, which enables support for a wide array of languages and scripts, including right-to-left (RTL) languages like Arabic and Hebrew.
Enabling the Advanced Text Generator
The Advanced Text Generator is currently under development and does not yet match the full functionality of the previous system. However, you can opt to use the new system for certain TextElement instances to take advantage of its current features. Here's how to activate it per project:
Navigate to the Project Settings window.
Find the UI Toolkit tab.
Check the “Enable Advanced Text Generator” option.


The Advanced Text Generator can now be selected in the UI Builder. 


Alternatively, once the option has been activated in the Project Settings, the system can be enabled programmatically like so:
textElement.style.unityTextGenerator = new StyleEnum<TextGeneratorType>(TextGeneratorType.Advanced);


Limitations:
The new system requires the Font file to be present, which introduces the following constraints:
Fonts must be dynamic, as static FontAsset support is not available.
Customization of glyph metrics is not supported.
The recommended workaround is to use FontEditing tools to customize the metrics or trim the Font itself.
Ongoing Development
As the Advanced Text System is evolving, certain functionalities remain under development:
Support for TextFields and selectable labels
RichText support
Synthetic Bold / Italic
Underline / Strikethrough
Spacing properties (character, word, paragraph)
Ellipsis
Events
Emoji Fallback
Parse Escape Sequence
ICU Data Package
Upon enabling the Advanced Text Generator, your project will include an ICUData file  icudt73l to ensure extensive language support. The file has a significant memory footprint at 4.8MB, but we are investigating options to reduce this footprint in future releases.


Corresponding Code:

---FontAsset.h---
#pragma once
#include <Modules/TextCoreFontEngine/Native/FontEngine.h>
#include <unordered_map>
#include <Runtime/BaseClasses/PPtr.h>
#include <unordered_set>


enum class TextFontWeight;
enum class FontStyles;
struct hb_font_t;

struct FontAsset
{
public:
    TextCore::FaceInfo faceInfo;
    PPtr<TextRendering::Font> sourceFontFile;
    GET_SET(PPtr<TextRendering::Font>, Font, sourceFontFile);
    #if UNITY_EDITOR
    PPtr<TextRendering::Font> sourceFontFile_EditorRef;
    GET_SET(PPtr<TextRendering::Font>, Font_Editor, sourceFontFile_EditorRef);
    #endif
    core::string sourceFontFilePath;
    dynamic_array<void*> fallbackFontAssetTable = {};
    dynamic_array<void*> fontWeightFallback = {};
    dynamic_array<void*> fontWeightItalicFallback = {};
    int fontInstanceID;

    FontAsset() : fontInstanceID(0), fallbackFontAssetTable({}), fontWeightFallback({}), fontWeightItalicFallback({}) {}

    bool operator==(const FontAsset& other) const {
        return sourceFontFile == other.sourceFontFile &&
            sourceFontFilePath == other.sourceFontFilePath &&
            faceInfo.familyName == other.faceInfo.familyName &&
            faceInfo.styleName == other.faceInfo.styleName &&
            fontInstanceID == other.fontInstanceID;
    }


    template<class TransferFunc>
    inline void Transfer(TransferFunc& transfer)
    {
        transfer.Transfer(faceInfo, "faceInfo");
        transfer.Transfer(sourceFontFile, "sourceFontFile");
        transfer.Transfer(sourceFontFilePath, "sourceFontFilePath");
        transfer.Transfer(fallbackFontAssetTable, "fallbackFontAssetTable");
    }

    static FontAsset* GetFontAssetForUnicode(void* mainFontAsset, const dynamic_array<void*>& globalFontAssetFallbacks, const FontStyles fontStyle, const TextFontWeight fontWeight, const long unicode);

    static void* Create(TextCore::FaceInfo faceInfo, TextRendering::Font* sourceFontFile, TextRendering::Font* sourceFontFile_EditorRef, core::string sourceFontFilePath, int fontInstanceID, dynamic_array<void*> fallbackFontAssetTable, dynamic_array<void*> fontWeightFallback, dynamic_array<void*> fontWeightItalicFallback);
    static void Destroy(void* ptr);

    static void UpdateFontEditorRef(void* ptr, TextRendering::Font* sourceFontFile_EditorRef);
    static void UpdateFallbacks(void* ptr, dynamic_array<void*> fallbackFontAssetTable);
    static void UpdateWeightFallbacks(void* ptr, dynamic_array<void*> fontWeightFallback, dynamic_array<void*> fontWeightItalicFallback);

    bool LoadFontFace(int fontSize = 0) const;
    hb_font_t* GetHbFontBySize(float fontSize);
    void ClearHbFonts();
    static void ClearAllHbFonts();
    static void FontDestroyedCallback(void* userData, void* sender, int eventType);
    FontAsset* GetFontAssetForUnicode(const long unicode);

private:
    FontAsset* GetFontAssetWithFallbackForUnicode(const FontStyles fontStyle, const TextFontWeight fontWeight, const long unicode);
    FontAsset* GetFontAssetWeightFallback(const FontStyles fontStyle, const TextFontWeight fontWeight);

    static dynamic_array<FontAsset*> s_FontAssets;
    std::unordered_map<float, hb_font_t*> m_HbFontsPerSize;
    void* m_PreviousFontFilePtr = nullptr;
};
BIND_MANAGED_TYPE_NAME(FontAsset, UnityEngine_TextCore_Text_FontAsset);

/// <summary>
/// Defines the potential font weights of a given font asset.
/// </summary>
enum class TextFontWeight
{
    Thin = 100,
    ExtraLight = 200,
    Light = 300,
    Regular = 400,
    Medium = 500,
    SemiBold = 600,
    Bold = 700,
    Heavy = 800,
    Black = 900,
};
BIND_MANAGED_TYPE_NAME(TextFontWeight, UnityEngine_TextCore_Text_TextFontWeight);

/// <summary>
 /// Font styles and text decorations
 /// </summary>
enum class FontStyles
{
    Normal = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    LowerCase = 8,
    UpperCase = 16,
    SmallCaps = 32,
    Strikethrough = 64,
    Superscript = 128,
    Subscript = 256,
    Highlight = 512,
};
BIND_MANAGED_TYPE_NAME(FontStyles, UnityEngine_TextCore_Text_FontStyles);

---LineInfo.h---
#pragma once
#include "TextSegment.h"

struct LineInfo
{
    int startGlyphIndex;
    int endGlyphIndex;
    int lineIndex; // starts at 0

    int lineWidth;
    int maxAscender;
    int minDescender;
    int yAdvance;
    int xOrigin;
    int yOrigin;

    dynamic_array<TextSegment*> segments;

    LineInfo(int startGlyphIndex, int endGlyphIndex, int lineIndex, int lineWidth, const dynamic_array<TextSegment*> &segments, int yOrigin = -1, int xOrigin = -1, int yAdvance = -1, int maxAscender = -INT_MAX, int minDescender = INT_MAX)
            : startGlyphIndex(startGlyphIndex), endGlyphIndex(endGlyphIndex), lineIndex(lineIndex), lineWidth(lineWidth), segments(segments),
              xOrigin(xOrigin), yOrigin(yOrigin), yAdvance(yAdvance), maxAscender(maxAscender), minDescender(minDescender)
    {
    }
};

---TextGenerationSettings.h---
#pragma once
#include "FontAsset.h"
#include "Runtime/Scripting/Marshalling/Marshalling.h"

enum class HorizontalAlignment
{
    Left,
    Center,
    Right,
    Justified
};
BIND_MANAGED_TYPE_NAME(HorizontalAlignment, UnityEngine_TextCore_HorizontalAlignment);

enum class VerticalAlignment
{
    Top,
    Middle,
    Bottom
};
BIND_MANAGED_TYPE_NAME(VerticalAlignment, UnityEngine_TextCore_VerticalAlignment);

enum class LanguageDirection
{
    LTR,     // Left to right language direction.
    RTL      // Right to left language direction.
};

BIND_MANAGED_TYPE_NAME(LanguageDirection, UnityEngine_TextCore_LanguageDirection);

struct TextGenerationSettings
{
public:
    void* fontAsset;
    dynamic_array<void*> globalFontAssetFallbacks;
    core::string text;
    int screenWidth;
    int screenHeight;
    float fontSize;
    bool wrapText;
    HorizontalAlignment horizontalAlignment;
    VerticalAlignment verticalAlignment;
    LanguageDirection languageDirection;

    ColorRGBA32 color;
    FontStyles fontStyle;
    TextFontWeight fontWeight;

    template<class TransferFunc>
    inline void Transfer(TransferFunc& transfer)
    {
        //transfer.Transfer(fontAsset, "fontAsset");
        transfer.Transfer(text, "text");
    }
};
BIND_MANAGED_TYPE_NAME(TextGenerationSettings, UnityEngine_TextCore_NativeTextGenerationSettings);


---TextShapingService.h---
#pragma once

#include "TextSegment.h"
#include "TextGenerationSettings.h"
#include "TextInfo.h"
#include <hb.h>

class TextShapingService {
public:
    TextShapingService();
    ~TextShapingService();

    void Init();
    void Shape(TextInfo& textInfo, dynamic_array<TextSegment>& textSegments);
    void ShapeSegment(TextSegment& segment);

    unsigned int glyphCount;
    dynamic_array<hb_glyph_info_t> glyphsInfo;
    dynamic_array<hb_glyph_position_t> glyphsPos;

private:
    hb_buffer_t* m_HbBuffer;
};



---TextInfo.h---
#pragma once
#include "TextElementInfo.h"

struct TextInfo
{
public:
    dynamic_array<TextElementInfo> textElementInfos;
    dynamic_array<int> fontAssetIds;
    dynamic_array<int> fontAssetLastGlyphIndex;

    void Reset()
    {
        textElementInfos.clear();
        fontAssetIds.clear();
        fontAssetLastGlyphIndex.clear();
    }
};
BIND_MANAGED_TYPE_NAME(TextInfo, UnityEngine_TextCore_Text_NativeTextInfo);

---ICUService.cpp---
#include "ICUService.h"
#include "TextCoreTextEngineScriptingClasses.h"

#include <Runtime/Utilities/FileUtilities.h>
#include <iostream>
#include <fstream>

// ICU4C
// Init
#include <uclean.h>
#include <unicode/udata.h>

// BIDI
#include <unicode/utypes.h>
#include <unicode/ubidi.h>

// Segmenter
#include <unicode/brkiter.h>
#include <unicode/locid.h>

bool ICUService::isICUDataLoaded = false;
bool ICUService::isMemoryFunctionsSet = false;
std::vector<char> ICUService::icuData;

void* U_CALLCONV my_malloc(const void *context, size_t size)
{
    (void)context;
    return UNITY_MALLOC(kMemTextLib, size);
}

void* U_CALLCONV my_realloc(const void *context, void* mem, size_t size)
{
    (void)context;
    return UNITY_REALLOC(kMemTextLib, mem, size);
}

void U_CALLCONV my_free(const void *context, void* mem)
{
    (void)context;
    if (mem)
        UNITY_FREE(kMemTextLib, mem);
}

ICUService::ICUService()
    : wordBreakIterator(nullptr)
    , characterBreakIterator(nullptr)
{
    if (!isMemoryFunctionsSet)
    {
        UErrorCode status = U_ZERO_ERROR;
        u_setMemoryFunctions(NULL, my_malloc, my_realloc, my_free, &status);
        if (U_FAILURE(status))
        {
            ErrorStringMsg("Could not set custom memory functions: %s", u_errorName(status));
            return;
        }
        isMemoryFunctionsSet = true;
    }

    LoadICUData();
}

ICUService::~ICUService()
{
    ubrk_close(wordBreakIterator);
    wordBreakIterator = nullptr;

    ubrk_close(characterBreakIterator);
    characterBreakIterator = nullptr;
}

void ICUService::Init(const TextGenerationSettings& tgs)
{
    logicalStr = icu::UnicodeString::fromUTF8(icu::StringPiece(tgs.text.data(), tgs.text.size()));
    SetWordBreakIterator();
    SetCharacterBreakIterator();
}

bool ICUService::LoadICUData()
{
    if (isICUDataLoaded)
        return true;

    auto managedSize = Scripting::UnityEngine::TextCore::Text::TextLibProxy::LoadAndCountICUdata();
    
    if(managedSize > 0)
    {
        icuData = std::vector<char>(managedSize);
        ScriptingSpan<UInt8> data((UInt8*)icuData.data(), icuData.size());

        Scripting::UnityEngine::TextCore::Text::TextLibProxy::GetICUdata(data, managedSize);

        UErrorCode err = U_ZERO_ERROR;
        udata_setCommonData(icuData.data(), &err);
        if (U_FAILURE(err)) {
            ErrorStringMsg("Error: Could not set ICU data: %s", u_errorName(err));
            return false;
        }

        err = U_ZERO_ERROR;
        u_init(&err);
        if (U_FAILURE(err)) {
            ErrorStringMsg("Error: Could not initialize ICU: %s", u_errorName(err));
            return false;
        }

        isICUDataLoaded = true;
        return true;

    }
    else
    {
        //File fallback
        core::string filePath = AppendPathName(GetApplicationContentsPath(), "Resources/icudt73l.dat");
        std::ifstream file(filePath, std::ios::binary | std::ios::ate);
        if (!file.is_open()) {
            ErrorStringMsg("Error: Could not open ICU data file");
            return false;
        }

        // Get the file size and read the data
        std::streamsize size = file.tellg();
        file.seekg(0, std::ios::beg);

        icuData = std::vector<char>(size);
        if (!file.read(icuData.data(), size)) {
            ErrorStringMsg("Error: Could not read ICU data file");
            return false;
        }

        UErrorCode err = U_ZERO_ERROR;
        udata_setCommonData(icuData.data(), &err);
        if (U_FAILURE(err)) {
            ErrorStringMsg("Error: Could not set ICU data: %s", u_errorName(err));
            return false;
        }

        err = U_ZERO_ERROR;
        u_init(&err);
        if (U_FAILURE(err)) {
            ErrorStringMsg("Error: Could not initialize ICU: %s", u_errorName(err));
            return false;
        }

        isICUDataLoaded = true;
        return true;
    }
}

void ICUService::TerminateICU()
{
    if (!isICUDataLoaded)
        return;

    UErrorCode err = U_ZERO_ERROR;
    u_cleanup();
    if (U_FAILURE(err)) {
        ErrorStringMsg("Error: Could not cleanup ICU: %s", u_errorName(err));
        return;
    }

    isICUDataLoaded = false;
    icuData.clear();
}

bool ICUService::IsLineEnding(int32_t i) const
{
    if (i >= logicalStr.length())
        return false;

    if (logicalStr[i] == '\n')
        return true;

    // Check for \r\n combination
    if (logicalStr[i] == '\r' && i + 1 < logicalStr.length() && logicalStr[i + 1] == '\n')
        return true;

    // Check for \r alone
    if (logicalStr[i] == '\r')
        return true;

    return false;
}

void ICUService::SkipLineEndings(int32_t& i, int32_t& p)
{
    int offset = 0; // No need to skip the characters of the first line ending encountered.
    while (IsLineEnding(i + offset))
    {
        // If it's a \r\n combination, skip both characters
        if (logicalStr[i + offset] == '\r' && i + 1 < logicalStr.length() && logicalStr[i + offset + 1] == '\n')
            i += 1 + offset;
        else // If it's either \n or \r alone, skip only one character
            i += offset;
        ++p;
        offset = 1;
    }
}

void ICUService::Bidi(const TextGenerationSettings& tgs, dynamic_array<TextSegment>& textSegments)
{
    UErrorCode err = U_ZERO_ERROR;
    UBiDi* para = ubidi_openSized(tgs.text.length(), 0, &err);
    if (U_FAILURE(err))
    {
        ubidi_close(para);
        ErrorStringMsg("Failed to open Bidi paragraph: %s", u_errorName(err));
        return;
    }

    int32_t start = 0, p = 0;
    for (int32_t i = 0; i <= logicalStr.length(); ++i)
    {
        if (i != logicalStr.length() && !IsLineEnding(i))
            continue;

        // See example: https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/ubidi_8h.html#aec250446cb8f9327eee5f219eaf65c25
        ubidi_setPara(para, logicalStr.getBuffer() + start, i - start, tgs.languageDirection == LanguageDirection::RTL ? UBIDI_RTL : UBIDI_LTR, NULL, &err);
        if (U_FAILURE(err))
        {
            ubidi_close(para);
            ErrorStringMsg("Failed to set paragraph: %s", u_errorName(err));
            return;
        }

        // Get the visual order
        int32_t count = ubidi_countRuns(para, &err);
        if (U_FAILURE(err))
        {
            ubidi_close(para);
            ErrorStringMsg("Failed to count runs: %s", u_errorName(err));
            return;
        }

        for (int32_t j = 0; j < count; ++j)
        {
            int32_t logicalStart, length;
            UBiDiDirection dir = ubidi_getVisualRun(para, j, &logicalStart, &length);

            uint8_t level = dir == UBIDI_LTR ? 0 : 1;
            textSegments.emplace_back(logicalStr.getBuffer(), logicalStart + start, length, level, p, tgs.fontSize, nullptr);
        }

        SkipLineEndings(i, p);
        start = i + 1;
    }

    ubidi_close(para);
}

void ICUService::SetWordBreakIterator()
{
    UErrorCode status = U_ZERO_ERROR;

    if (!LoadICUData())
        return;

    if (wordBreakIterator == nullptr)
    {
        wordBreakIterator = ubrk_open(UBRK_WORD, 0, logicalStr.getBuffer(), logicalStr.length(), &status);
        if (U_FAILURE(status)) {
            ErrorStringMsg("Error creating Word BreakIterator: %s", u_errorName(status));
            ubrk_close(wordBreakIterator);
            wordBreakIterator = nullptr;
        }
        return;
    }

    ubrk_setText(wordBreakIterator, logicalStr.getBuffer(), logicalStr.length(), &status);
}

void ICUService::SetCharacterBreakIterator()
{
    UErrorCode status = U_ZERO_ERROR;

    if (!LoadICUData())
        return;

    if (characterBreakIterator == nullptr)
    {
        characterBreakIterator = ubrk_open(UBRK_CHARACTER, 0, logicalStr.getBuffer(), logicalStr.length(), &status);
        if (U_FAILURE(status)) {
            ErrorStringMsg("Error creating Character BreakIterator: %s", u_errorName(status));
            return;
        }
    }

    ubrk_setText(characterBreakIterator, logicalStr.getBuffer(), logicalStr.length(), &status);
}

---TextLib.cpp---
#include "TextLib.h"
#include "TextUtilities.h"
#include "ICUService.h"
#include "Runtime/Profiler/Profiler.h"

// FreeType
#include <freetype/freetype.h>
#include "TextUtilities.h"
#include <hb-ft.h>

PROFILER_INFORMATION(gGenerateText, "GenerateText", kProfilerText)
PROFILER_INFORMATION(gBidiText, "BidiText", kProfilerText)
PROFILER_INFORMATION(gLookupFontText, "LookupFontText", kProfilerText)
PROFILER_INFORMATION(gShapeText, "ShapeText", kProfilerText)
PROFILER_INFORMATION(gLayoutText, "LayoutText", kProfilerText)

void* TextLib::Create()
{
    return UNITY_NEW(TextLib, kMemTextLib);
}

void TextLib::Destroy(void* ptr)
{
    auto* cast_ptr = (TextLib*)ptr;
    UNITY_DELETE(cast_ptr, kMemTextLib);
}

void TextLib::Init(const TextGenerationSettings& tgs)
{
    textInfo.Reset();
    m_TextSegments.clear();
    m_LineInfos.clear();
    m_ICUService.Init(tgs);
    m_TextShapingService.Init();
}

TextInfo TextLib::GenerateText(const TextGenerationSettings& tgs)
{
    PROFILER_BEGIN(gGenerateText);
    Init(tgs);

    PROFILER_BEGIN(gBidiText);
    m_ICUService.Bidi(tgs, m_TextSegments);
    PROFILER_END(gBidiText);

    PROFILER_BEGIN(gLookupFontText);
    SplitSegmentsPerFont(tgs);
    PROFILER_END(gLookupFontText);

    if (m_TextSegments.size() == 0)
        return textInfo;

    PROFILER_BEGIN(gShapeText);
    m_TextShapingService.Shape(textInfo, m_TextSegments);
    PROFILER_END(gShapeText);

    PROFILER_BEGIN(gLayoutText);
    Layout(tgs);
    PROFILER_END(gLayoutText);

    PROFILER_END(gGenerateText);
    return textInfo;
}

void TextLib::SplitSegmentsPerFont(const TextGenerationSettings& tgs)
{
    dynamic_array<TextSegment> textSegmentsWithFontAsset;
    textSegmentsWithFontAsset.reserve(m_TextSegments.size());
    for (auto & segment : m_TextSegments)
    {
        ProcessSegment(segment, textSegmentsWithFontAsset, tgs);
    }
    m_TextSegments = textSegmentsWithFontAsset;

    textInfo.fontAssetIds.resize_uninitialized(textSegmentsWithFontAsset.size());
    textInfo.fontAssetLastGlyphIndex.resize_uninitialized(textSegmentsWithFontAsset.size());
}

void TextLib::ProcessSegment(const TextSegment& segment, dynamic_array<TextSegment>& textSegmentsWithFontAsset, const TextGenerationSettings& tgs)
{
    const bool isRTL = segment.IsRTL();
    const auto* segmentText = reinterpret_cast<const uint16_t*>(segment.GetSegmentText());
    int currentIndex = isRTL ? segment.start + segment.length : segment.start;
    const int step = isRTL ? -1 : 1;
    const int start = isRTL ? segment.length - 1 : 0;
    const int end = isRTL ? -1 : segment.length;
    FontAsset* prevFA = nullptr;

    for (int i = start; i != end; i += step)
    {
        bool wasSurrogate = false;
        const long unicode = TextUtilities::GetUnicodeCodePoint(segmentText, i, segment.length, isRTL, wasSurrogate);
        auto fontAsset = FontAsset::GetFontAssetForUnicode(tgs.fontAsset, tgs.globalFontAssetFallbacks, tgs.fontStyle, tgs.fontWeight, unicode);
        AssertMsg(fontAsset != nullptr, "Font asset is null");

        if (prevFA != fontAsset && (i != start))
        {
            auto hbFont = prevFA->GetHbFontBySize(tgs.fontSize);
            if (hbFont != nullptr) {
                if (isRTL)
                    AddTextSegmentWithFontAsset(i + 1 + segment.start, currentIndex - (i + 1 + segment.start), prevFA, segment, textSegmentsWithFontAsset);
                else
                    AddTextSegmentWithFontAsset(currentIndex, i + segment.start - currentIndex, prevFA, segment, textSegmentsWithFontAsset);
            }
            
            currentIndex = i + segment.start + (isRTL ? 1 : 0);
        }

        if (wasSurrogate)
            i += step;

        if (i == end - step)
        {
            auto hbFont = fontAsset->GetHbFontBySize(tgs.fontSize);
            if (hbFont != nullptr) {
                if (isRTL)
                    AddTextSegmentWithFontAsset(segment.start, currentIndex - segment.start, fontAsset, segment, textSegmentsWithFontAsset);
                else
                    AddTextSegmentWithFontAsset(currentIndex, segment.length - (currentIndex - segment.start), fontAsset, segment, textSegmentsWithFontAsset);
            }
            
            break;
        }
        prevFA = fontAsset;
    }
}

void TextLib::AddTextSegmentWithFontAsset(int start, int length, FontAsset* fontAsset, const TextSegment& segment, dynamic_array<TextSegment>& textSegmentsWithFontAsset) const
{
    textSegmentsWithFontAsset.emplace_back(
            TextSegment(
                    m_ICUService.logicalStr.getBuffer(),
                    start,
                    length,
                    segment.level,
                    segment.lineIndex,
                    segment.fontSize,
                    fontAsset
            )
    );
}

const TextSegment* TextLib::FindSegmentByGlyphIndex(int i) const
{
    for (const auto& segment : m_TextSegments)
    {
        if(segment.firstGlyphIndex <= i && segment.firstGlyphIndex + segment.glyphCount > i)
            return &segment;
    }
    return nullptr;
}

bool TextLib::ShouldRollBack(int i, int lineGlyphIndexStart, int breakPoint, const hb_glyph_info_t &glyphInfo, const TextSegment* currentSegment) const
{
    bool isRTL = currentSegment->IsRTL();
    bool commonCondition = ((glyphInfo.cluster + currentSegment->start >= breakPoint) ||
                            u_isspace(currentSegment->GetSegmentText()[glyphInfo.cluster]));

    bool ltrCondition = i > 0 && i > lineGlyphIndexStart && commonCondition;

    bool rtlCondition = i < currentSegment->glyphCount && i < lineGlyphIndexStart && commonCondition;

    return isRTL ? rtlCondition : ltrCondition;
}

bool TextLib::IsLastGlyph(int i, const TextSegment& segment)
{
    return segment.IsRTL() ? i == segment.firstGlyphIndex : i == segment.firstGlyphIndex + segment.glyphCount - 1;
}

int TextLib::ComputeLogicalBreakPoint(int i, int lineGlyphIndexStart, const TextSegment& segment, const hb_glyph_info_t& glyphInfo) const
{
    int breakPointOffset = segment.IsRTL() ? 0 : 1;
    int logicalBreakPointIndex = 0;

    if (m_ICUService.wordBreakIterator)
        logicalBreakPointIndex = ubrk_preceding(m_ICUService.wordBreakIterator, glyphInfo.cluster + breakPointOffset + segment.start);

    auto lineIndexLogicalStart = m_TextShapingService.glyphsInfo.data()[lineGlyphIndexStart].cluster + FindSegmentByGlyphIndex(lineGlyphIndexStart)->start;
    if (logicalBreakPointIndex == icu::BreakIterator::DONE || logicalBreakPointIndex <= lineIndexLogicalStart)
    {
        if (m_ICUService.characterBreakIterator)
            logicalBreakPointIndex = ubrk_preceding(m_ICUService.characterBreakIterator, glyphInfo.cluster + breakPointOffset + segment.start);

        if (logicalBreakPointIndex == icu::BreakIterator::DONE)
            logicalBreakPointIndex = 0;
    }

    return logicalBreakPointIndex;
}

void TextLib::ResetLineValues(int& minLineGlyphIndex, int& maxLineGlyphIndex, dynamic_array<TextSegment*>& lineSegments, int& xAdvance)
{
    xAdvance = 0;
    minLineGlyphIndex = INT32_MAX;
    maxLineGlyphIndex = INT32_MIN;
    lineSegments.clear();
}

// Skip whitespace at the beginning of the line
int TextLib::SkipWhiteSpaces(int& i, const TextSegment &segment)
{
    auto glyphCount = m_TextShapingService.glyphCount;
    auto glyphsInfo = m_TextShapingService.glyphsInfo.data();

    while (i < glyphCount && i > 0 && u_isspace(segment.GetSegmentText()[glyphsInfo[i].cluster]))
        segment.IsRTL() ? --i : ++i;

    return i;
}

void TextLib::Layout(const TextGenerationSettings& tgs)
{
    int xAdvance = 0;
    int firstGlyphIndex = 0;
    int lastGlyphIndex = 0;
    int lineGlyphIndexStart = -1;
    int minLineGlyphIndex = INT32_MAX;
    int maxLineGlyphIndex = INT32_MIN;
    int lineIndex = m_TextSegments.front().lineIndex;
    int wordWrapLineOffset = 0;
    bool justWrapped = false;

    auto glyphCount = m_TextShapingService.glyphCount;
    auto glyphsInfo = m_TextShapingService.glyphsInfo.data();
    auto glyphsPos = m_TextShapingService.glyphsPos.data();
    dynamic_array<TextSegment*> lineSegments;

    textInfo.textElementInfos.resize_initialized(glyphCount);

    for (auto& segment : m_TextSegments)
    {
        bool isRTL = segment.IsRTL();
        firstGlyphIndex = isRTL ? segment.firstGlyphIndex + segment.glyphCount - 1 : segment.firstGlyphIndex;
        lastGlyphIndex = isRTL ? segment.firstGlyphIndex : segment.firstGlyphIndex + segment.glyphCount;
        if (lineGlyphIndexStart == -1)
            lineGlyphIndexStart = firstGlyphIndex;

        // This segment is on a new line (\n)
        // Note that word wrap might have already caused a line break before this segment.
        auto lineOffset = justWrapped ? segment.lineIndex - lineIndex - 1 : segment.lineIndex - lineIndex;
        if (lineOffset > 0)
        {
            if (maxLineGlyphIndex > 0) // Only add newline if there is something to add
            {
                m_LineInfos.emplace_back(minLineGlyphIndex, maxLineGlyphIndex, lineIndex + wordWrapLineOffset, xAdvance,
                                         lineSegments);
                lineGlyphIndexStart = firstGlyphIndex;
                ResetLineValues(minLineGlyphIndex, maxLineGlyphIndex, lineSegments, xAdvance);
            }
            lineIndex = justWrapped ? segment.lineIndex - 1 : segment.lineIndex;
        }

        lineSegments.emplace_back(&segment);
        for (int i = firstGlyphIndex; isRTL ? i >= lastGlyphIndex : i < lastGlyphIndex; isRTL ? --i : ++i)
        {
            justWrapped = false;
            if (xAdvance == 0 && u_isspace(segment.GetSegmentText()[glyphsInfo[i].cluster]))
                lineGlyphIndexStart = SkipWhiteSpaces(i, segment);

            minLineGlyphIndex = std::min(minLineGlyphIndex, i);
            maxLineGlyphIndex = std::max(maxLineGlyphIndex, i);
            auto glyphPos = glyphsPos[i];
            auto glyphInfo = glyphsInfo[i];
            xAdvance += glyphPos.x_advance;

            if (tgs.wrapText && xAdvance > tgs.screenWidth)
            {
                int logicalBreakPointIndex = ComputeLogicalBreakPoint(i, lineGlyphIndexStart, segment, glyphInfo);

                // Remove segment if first glyph caused a line break and it is not the only segment in the line.
                if(lineSegments.size() > 1 && i == segment.firstGlyphIndex)
                    lineSegments.pop_back();

                // Roll back to the last safe break point that is not a whitespace.
                const auto* currentSegment = &segment;
                while (ShouldRollBack(i, lineGlyphIndexStart, logicalBreakPointIndex, glyphInfo, currentSegment))
                {
                    xAdvance -= glyphPos.x_advance;
                    if (currentSegment->IsRTL())
                    {
                        i++;
                        minLineGlyphIndex++;
                    }
                    else
                    {
                        i--;
                        maxLineGlyphIndex--;
                    }
                    glyphPos = glyphsPos[i];
                    glyphInfo = glyphsInfo[i];
                    currentSegment = FindSegmentByGlyphIndex(i);
                }

                m_LineInfos.emplace_back(minLineGlyphIndex, maxLineGlyphIndex, lineIndex + wordWrapLineOffset, xAdvance, lineSegments);
                lineGlyphIndexStart = isRTL ? i - 1 : i + 1;
                justWrapped = true;
                wordWrapLineOffset++;
                ResetLineValues(minLineGlyphIndex, maxLineGlyphIndex, lineSegments, xAdvance);

                // Segments can span on multiple lines, add current segment to the new line.
                if ((!isRTL && i < (segment.firstGlyphIndex + segment.glyphCount - 1)) || (isRTL && i > segment.firstGlyphIndex))
                    lineSegments.emplace_back(&segment);
            }
            else if (IsLastGlyph(i, m_TextSegments.back()))
            {
                m_LineInfos.emplace_back(minLineGlyphIndex, maxLineGlyphIndex, lineIndex + wordWrapLineOffset, xAdvance, lineSegments);
            }
        }
    }

    const int totalHeight = CalculateTotalHeight(m_LineInfos, tgs);
    for(auto& lineInfo : m_LineInfos)
    {
        lineInfo.xOrigin = CalculateXOrigin(lineInfo, tgs);
        lineInfo.yOrigin = CalculateYOrigin(totalHeight, tgs);
        AlignAndGenerateVerticesForLine(lineInfo, tgs);
    }
}

int TextLib::CalculateTotalHeight(dynamic_array<LineInfo>& lineInfos, const TextGenerationSettings& tgs)
{
    int totalHeight = 0;
    int maxLineHeight = 0;
    int previousLineOffset = 0;

    for (int i = 0; i < lineInfos.size(); ++i)
    {
        auto& lineInfo = lineInfos[i];
        for (auto& segment : lineInfo.segments)
        {
            hb_font_extents_t fontExtents;
            hb_font_get_extents_for_direction(segment->GetHbFont(), segment->IsRTL() ? HB_DIRECTION_RTL : HB_DIRECTION_LTR , &fontExtents);

            lineInfo.maxAscender = std::max(lineInfo.maxAscender, fontExtents.ascender);
            lineInfo.minDescender = std::min(lineInfo.minDescender, fontExtents.descender);
            auto lineGap = (i < lineInfos.size() - 1) ? fontExtents.line_gap : 0;

            auto lineHeight = lineInfo.maxAscender - lineInfo.minDescender - lineGap;
            maxLineHeight = std::max(maxLineHeight, lineHeight);
        }

        int yOffsetForNewLines = 0;
        if (i + previousLineOffset < lineInfo.lineIndex)
        {
            yOffsetForNewLines = (lineInfo.lineIndex - i - previousLineOffset) * maxLineHeight;
            previousLineOffset += lineInfo.lineIndex - i;
        }

        if (tgs.verticalAlignment == VerticalAlignment::Top)
        {
            lineInfo.yAdvance = totalHeight + yOffsetForNewLines;
            totalHeight += maxLineHeight + yOffsetForNewLines;
        }
        else
        {
            totalHeight += maxLineHeight + yOffsetForNewLines;
            lineInfo.yAdvance = totalHeight;
        }
    }
    return totalHeight;
}

int TextLib::CalculateXOrigin(const LineInfo& lineInfo, const TextGenerationSettings& tgs)
{
    switch (tgs.horizontalAlignment)
    {
        case HorizontalAlignment::Center:
            return (tgs.screenWidth - lineInfo.lineWidth) * 0.5;
        case HorizontalAlignment::Right:
            return tgs.screenWidth - lineInfo.lineWidth;
        default: // Left alignment and other cases
            return 0;
    }
}

int TextLib::CalculateYOrigin(const int totalHeight, const TextGenerationSettings& tgs)
{
    switch (tgs.verticalAlignment)
    {
        case VerticalAlignment::Middle:
            return (tgs.screenHeight - totalHeight) * 0.5;
        case VerticalAlignment::Bottom:
            return tgs.screenHeight - totalHeight;
        default: // Top
            return 0;
    }
}

void TextLib::ApplyVerticalAlignment(Vector3f& vertex, const LineInfo& lineInfo, const TextGenerationSettings& tgs)
{
    switch (tgs.verticalAlignment)
    {
        case VerticalAlignment::Middle:
        case VerticalAlignment::Bottom:
            vertex.y = lineInfo.yOrigin + lineInfo.yAdvance - vertex.y + lineInfo.minDescender;
            break;
        default: // Top
            vertex.y = -vertex.y + lineInfo.yAdvance + lineInfo.maxAscender;
            break;
    }
}

void TextLib::AlignAndGenerateVerticesForLine(const LineInfo& lineInfo, const TextGenerationSettings& tgs)
{
    int xOrigin = lineInfo.xOrigin;
    for (auto& segment : lineInfo.segments)
    {
        int startIndex = std::max(segment->firstGlyphIndex, lineInfo.startGlyphIndex);
        int endIndex = std::min(segment->firstGlyphIndex + segment->glyphCount - 1, lineInfo.endGlyphIndex);
        for (int i = startIndex; i <= endIndex; ++i)
        {
            auto glyphPos = m_TextShapingService.glyphsPos[i];
            auto glyphInfo = m_TextShapingService.glyphsInfo[i];

            hb_glyph_extents_t extents;

            bool result = hb_font_get_glyph_extents(segment->GetHbFont(), glyphInfo.codepoint, &extents);
            if (!result)
                ErrorStringMsg("Failed to get glyph extents");

            int glyphWidth = extents.width;
            int glyphHeight = extents.height;
            int xBearing = extents.x_bearing;
            int yBearing = extents.y_bearing;

            int xOffset = glyphPos.x_offset;
            int yOffset = glyphPos.y_offset;

            // Mesh Generation in FreeType coordinate system

            float left = xOrigin + xBearing + xOffset;
            float right = xOrigin + xBearing + glyphWidth + xOffset;
            float bottom = glyphHeight + yBearing + yOffset;
            float top = yBearing + yOffset;

            Vector3f bottomLeft = Vector3f(left, bottom, 0);
            Vector3f topLeft = Vector3f(left, top, 0);
            Vector3f topRight = Vector3f(right, top, 0);
            Vector3f bottomRight = Vector3f(right, bottom, 0);

            // Convert to Unity coordinate system
            ApplyVerticalAlignment(bottomLeft, lineInfo, tgs);
            ApplyVerticalAlignment(topLeft, lineInfo, tgs);
            ApplyVerticalAlignment(topRight, lineInfo, tgs);
            ApplyVerticalAlignment(bottomRight, lineInfo, tgs);

            // We divide by 64 to get float precision instead of int
            textInfo.textElementInfos[i].bottomLeft = TextCoreVertex{bottomLeft / 64.0f, tgs.color, Vector2f{0, 0},
                                                                     Vector2f{0, 0}};
            textInfo.textElementInfos[i].topLeft = TextCoreVertex{topLeft / 64.0f, tgs.color, Vector2f{0, 0}, Vector2f{0, 0}};
            textInfo.textElementInfos[i].topRight = TextCoreVertex{topRight / 64.0f, tgs.color, Vector2f{0, 0}, Vector2f{0, 0}};
            textInfo.textElementInfos[i].bottomRight = TextCoreVertex{bottomRight / 64.0f, tgs.color, Vector2f{0, 0},
                                                                      Vector2f{0, 0}};

            textInfo.textElementInfos[i].glyphID = glyphInfo.codepoint;
            xOrigin += glyphPos.x_advance;
        }
    }
}

---TextShapingService.cpp---
#include "TextShapingService.h"

#include <hb-ft.h>
#include <hb.h>

TextShapingService::TextShapingService()
{
    m_HbBuffer = hb_buffer_create();
}

TextShapingService::~TextShapingService()
{
    hb_buffer_destroy(m_HbBuffer);
}

void TextShapingService::Init()
{
    glyphsInfo.clear();
    glyphsPos.clear();
    glyphCount = 0;
}

void TextShapingService::Shape(TextInfo& textInfo, dynamic_array<TextSegment>& textSegments)
{
    glyphCount = 0;
    int i = 0;
    for (auto& segment : textSegments) {
        TextShapingService::ShapeSegment(segment);
        textInfo.fontAssetIds[i] = segment.fontAsset->fontInstanceID;
        textInfo.fontAssetLastGlyphIndex[i] = segment.lastGlyphIndex;
        i++;
    }
}

void TextShapingService::ShapeSegment(TextSegment& segment)
{
    const auto* text = reinterpret_cast<const uint16_t*>(segment.GetSegmentText());
    hb_buffer_clear_contents(m_HbBuffer);
    hb_buffer_add_utf16(m_HbBuffer, text, segment.length, 0, -1);

    hb_buffer_guess_segment_properties(m_HbBuffer);
    hb_buffer_set_direction(m_HbBuffer, segment.IsRTL() ? HB_DIRECTION_RTL : HB_DIRECTION_LTR);
   /* hb_buffer_set_script(m_HbBuffer, script);
    hb_buffer_set_language(m_HbBuffer, hb_language_from_string(language, -1));*/

    hb_shape(segment.GetHbFont(), m_HbBuffer, NULL, 0);

    unsigned int currentGlyphCount;
    // Get glyph information and positions out of the buffer
    auto currentGlyphsInfo = hb_buffer_get_glyph_infos(m_HbBuffer, &currentGlyphCount);
    auto currentGlyphsPos = hb_buffer_get_glyph_positions(m_HbBuffer, &currentGlyphCount);

    segment.firstGlyphIndex = glyphCount;
    segment.glyphCount = currentGlyphCount;

    for (int i = 0; i < currentGlyphCount; i++)
    {
        glyphsInfo.push_back(currentGlyphsInfo[i]);
        glyphsPos.push_back(currentGlyphsPos[i]);
    }

    segment.firstGlyphIndex = glyphCount;
    glyphCount += currentGlyphCount;
    segment.lastGlyphIndex = glyphCount;
}

---TextLib.h---
#pragma once

#include "TextGenerationSettings.h"
#include "TextInfo.h"
#include "LineInfo.h"
#include "ICUService.h"
#include "TextShapingService.h"
#include "TextSegment.h"

struct hb_glyph_info_t;

class TextLib
{
public:
    static void* Create();
    static void Destroy(void* ptr);
    TextInfo GenerateText(const TextGenerationSettings& tgs); // TODO can we skip copy of TextInfo

    TextInfo textInfo;
    friend class TestUtils;

private:
    static bool IsLastGlyph(int i, const TextSegment& segment);
    static int CalculateTotalHeight(dynamic_array<LineInfo>& lineInfos, const TextGenerationSettings& tgs);
    static int CalculateXOrigin(const LineInfo& lineInfo, const TextGenerationSettings& tgs);
    static int CalculateYOrigin(int totalHeight, const TextGenerationSettings& tgs);
    static void ApplyVerticalAlignment(Vector3f& vertex, const LineInfo& lineInfo, const TextGenerationSettings& tgs);

    void Init(const TextGenerationSettings& textGenerationSettings);
    void SplitSegmentsPerFont(const TextGenerationSettings& tgs);
    void ProcessSegment(const TextSegment& segment, dynamic_array<TextSegment>& textSegmentsWithFontAsset, const TextGenerationSettings& tgs);
    void AddTextSegmentWithFontAsset(int start, int length, FontAsset* fontAsset, const TextSegment& segment, dynamic_array<TextSegment>& textSegmentsWithFontAsset) const;

    void Layout(const TextGenerationSettings& tgs);
    int ComputeLogicalBreakPoint(int i, int lineGlyphIndexStart, const TextSegment& segment, const hb_glyph_info_t& glyphInfo) const;
    void ResetLineValues(int& minLineGlyphIndex, int& maxLineGlyphIndex, dynamic_array<TextSegment*>& lineSegments, int& xAdvance);
    int SkipWhiteSpaces(int& i, const TextSegment &segment);
    bool ShouldRollBack(int i, int lineGlyphIndexStart, int breakPoint, const hb_glyph_info_t &glyphInfo, const TextSegment* segment) const;
    const TextSegment* FindSegmentByGlyphIndex(int index) const;
    void AlignAndGenerateVerticesForLine(const LineInfo& lineInfo, const TextGenerationSettings& tgs);

    ICUService m_ICUService;
    TextShapingService m_TextShapingService;

    dynamic_array<TextSegment> m_TextSegments;
    dynamic_array<LineInfo> m_LineInfos;
};
BIND_MANAGED_TYPE_NAME(TextLib, UnityEngine_TextCore_Text_TextLib)

---ICUService.h---
#pragma once

#include "TextSegment.h"
#include "TextGenerationSettings.h"

#include <list>

#include <unicode/uchar.h>
#include <brkiter.h>

class ICUService {
public:
    ICUService();
    ~ICUService();

    void Init(const TextGenerationSettings& textGenerationSettings);
    void Bidi(const TextGenerationSettings& tgs, dynamic_array<TextSegment>& textSegments);
    void SetWordBreakIterator();
    void SetCharacterBreakIterator();

    icu::UnicodeString logicalStr;
    UBreakIterator* wordBreakIterator;
    UBreakIterator* characterBreakIterator;

    friend class TestUtils;
private:
    static bool LoadICUData();
    static void TerminateICU();
    static bool isMemoryFunctionsSet;
    static bool isICUDataLoaded;
    static std::vector<char> icuData;

    bool IsLineEnding(int32_t i) const;
    void SkipLineEndings(int32_t& i, int32_t& p);
};

---TextElementInfo.h---
#pragma once
#include "TextCoreVertex.h"

struct TextElementInfo
{
public:
    int glyphID;
    TextCoreVertex bottomLeft;
    TextCoreVertex topLeft;
    TextCoreVertex topRight;
    TextCoreVertex bottomRight;
};
BIND_MANAGED_TYPE_NAME(TextElementInfo, UnityEngine_TextCore_Text_NativeTextElementInfo);

---TextLib.cpp.orig---
#include "TextLib.h"
#include "ICUService.h"
#include "Runtime/Profiler/Profiler.h"

// FreeType
#include <freetype/freetype.h>
#include "TextUtilities.h"
#include <hb-ft.h>

PROFILER_INFORMATION(gGenerateText, "GenerateText", kProfilerText)
PROFILER_INFORMATION(gBidiText, "BidiText", kProfilerText)
PROFILER_INFORMATION(gLookupFontText, "LookupFontText", kProfilerText)
PROFILER_INFORMATION(gShapeText, "ShapeText", kProfilerText)
PROFILER_INFORMATION(gLayoutText, "LayoutText", kProfilerText)

void* TextLib::Create()
{
    return UNITY_NEW(TextLib, kMemTextLib);
}

void TextLib::Destroy(void* ptr)
{
    auto* cast_ptr = (TextLib*)ptr;
    UNITY_DELETE(cast_ptr, kMemTextLib);
}

void TextLib::Init(const TextGenerationSettings& tgs)
{
    textInfo.Reset();
    m_TextSegments.clear();
    m_LineInfos.clear();
    m_ICUService.Init(tgs);
    m_TextShapingService.Init();
}

TextInfo TextLib::GenerateText(const TextGenerationSettings& tgs)
{
    PROFILER_BEGIN(gGenerateText);
    Init(tgs);

    PROFILER_BEGIN(gBidiText);
    m_ICUService.Bidi(tgs, m_TextSegments);
    PROFILER_END(gBidiText);

    PROFILER_BEGIN(gLookupFontText);
    SplitSegmentsPerFont(tgs);
    PROFILER_END(gLookupFontText);

    PROFILER_BEGIN(gShapeText);
    m_TextShapingService.Shape(textInfo, m_TextSegments);
    PROFILER_END(gShapeText);

    PROFILER_BEGIN(gLayoutText);
    Layout(tgs);
    PROFILER_END(gLayoutText);

    PROFILER_END(gGenerateText);
    return textInfo;
}

void TextLib::SplitSegmentsPerFont(const TextGenerationSettings& tgs)
{
    dynamic_array<TextSegment> textSegmentsWithFontAsset;
    textSegmentsWithFontAsset.reserve(m_TextSegments.size());
    for (auto & segment : m_TextSegments)
    {
        ProcessSegment(segment, textSegmentsWithFontAsset, tgs);
    }
    m_TextSegments = textSegmentsWithFontAsset;

    textInfo.fontAssetIds.resize_uninitialized(textSegmentsWithFontAsset.size());
    textInfo.fontAssetLastGlyphIndex.resize_uninitialized(textSegmentsWithFontAsset.size());
}

void TextLib::ProcessSegment(const TextSegment& segment, dynamic_array<TextSegment>& textSegmentsWithFontAsset, const TextGenerationSettings& tgs)
{
    const bool isRTL = segment.IsRTL();
    const auto* segmentText = reinterpret_cast<const uint16_t*>(segment.GetSegmentText());
    int currentIndex = isRTL ? segment.start + segment.length : segment.start;
    const int step = isRTL ? -1 : 1;
    const int start = isRTL ? segment.length - 1 : 0;
    const int end = isRTL ? -1 : segment.length;
    FontAsset* prevFA = nullptr;

    for (int i = start; i != end; i += step)
    {
        bool wasSurrogate = false;
        const long unicode = TextUtilities::GetUnicodeCodePoint(segmentText, i, segment.length, isRTL, wasSurrogate);
        auto fontAsset = FontAsset::GetFontAssetForUnicode(tgs.fontAsset, tgs.globalFontAssetFallbacks, tgs.fontStyle, tgs.fontWeight, unicode);
        AssertMsg(fontAsset != nullptr, "Font asset is null");

        if (prevFA != fontAsset && (i != start))
        {
            auto hbFont = prevFA->GetHbFontBySize(tgs.fontSize);
            if (isRTL)
                AddTextSegmentWithFontAsset(i + 1 + segment.start, currentIndex - (i + 1 + segment.start), prevFA, segment, textSegmentsWithFontAsset);
            else
                AddTextSegmentWithFontAsset(currentIndex, i + segment.start - currentIndex, prevFA, segment, textSegmentsWithFontAsset);
            currentIndex = i + segment.start + (isRTL ? 1 : 0);
        }

        if (wasSurrogate)
            i += step;

        if (i == end - step)
        {
            auto hbFont = fontAsset->GetHbFontBySize(tgs.fontSize);
            if (isRTL)
                AddTextSegmentWithFontAsset(segment.start, currentIndex - segment.start, fontAsset, segment, textSegmentsWithFontAsset);
            else
                AddTextSegmentWithFontAsset(currentIndex, segment.length - (currentIndex - segment.start), fontAsset, segment, textSegmentsWithFontAsset);
            break;
        }
        prevFA = fontAsset;
    }
}

void TextLib::AddTextSegmentWithFontAsset(int start, int length, FontAsset* fontAsset, const TextSegment& segment, dynamic_array<TextSegment>& textSegmentsWithFontAsset) const
{
    textSegmentsWithFontAsset.emplace_back(
            TextSegment(
                    m_ICUService.logicalStr.getBuffer(),
                    start,
                    length,
                    segment.level,
                    segment.lineIndex,
                    segment.fontSize,
                    fontAsset
            )
    );
}

const TextSegment* TextLib::FindSegmentByGlyphIndex(int i) const
{
    for (const auto& segment : m_TextSegments)
    {
        if(segment.firstGlyphIndex <= i && segment.firstGlyphIndex + segment.glyphCount > i)
            return &segment;
    }
    return nullptr;
}

bool TextLib::ShouldRollBack(int i, int lineGlyphIndexStart, int breakPoint, const hb_glyph_info_t &glyphInfo, const TextSegment* currentSegment) const
{
    bool isRTL = currentSegment->IsRTL();
    bool commonCondition = ((glyphInfo.cluster + currentSegment->start >= breakPoint) ||
                            u_isspace(currentSegment->GetSegmentText()[glyphInfo.cluster]));

    bool ltrCondition = i > 0 && i > lineGlyphIndexStart && commonCondition;

    bool rtlCondition = i < currentSegment->glyphCount && i < lineGlyphIndexStart && commonCondition;

    return isRTL ? rtlCondition : ltrCondition;
}

bool TextLib::IsLastGlyph(int i, const TextSegment& segment)
{
    return segment.IsRTL() ? i == segment.firstGlyphIndex : i == segment.firstGlyphIndex + segment.glyphCount - 1;
}

int TextLib::ComputeLogicalBreakPoint(int i, int lineGlyphIndexStart, const TextSegment& segment, const hb_glyph_info_t& glyphInfo) const
{
    int breakPointOffset = segment.IsRTL() ? 0 : 1;
    int logicalBreakPointIndex = 0;

    if (m_ICUService.wordBreakIterator)
        logicalBreakPointIndex = m_ICUService.wordBreakIterator->preceding(glyphInfo.cluster + breakPointOffset + segment.start);

    auto lineIndexLogicalStart = m_TextShapingService.glyphsInfo.data()[lineGlyphIndexStart].cluster + FindSegmentByGlyphIndex(lineGlyphIndexStart)->start;
    if (logicalBreakPointIndex == icu::BreakIterator::DONE || logicalBreakPointIndex <= lineIndexLogicalStart)
    {
        if (m_ICUService.characterBreakIterator)
            logicalBreakPointIndex = m_ICUService.characterBreakIterator->preceding(glyphInfo.cluster + breakPointOffset + segment.start);

        if (logicalBreakPointIndex == icu::BreakIterator::DONE)
            logicalBreakPointIndex = 0;
    }

    return logicalBreakPointIndex;
}

void TextLib::ResetLineValues(int& minLineGlyphIndex, int& maxLineGlyphIndex, dynamic_array<TextSegment*>& lineSegments, int& xAdvance)
{
    xAdvance = 0;
    minLineGlyphIndex = INT32_MAX;
    maxLineGlyphIndex = INT32_MIN;
    lineSegments.clear();
}

// Skip whitespace at the beginning of the line
int TextLib::SkipWhiteSpaces(int& i, const TextSegment &segment, std::function<void(int&)> nextIndex)
{
    auto glyphCount = m_TextShapingService.glyphCount;
    auto glyphsInfo = m_TextShapingService.glyphsInfo.data();

    while (i < glyphCount && i > 0 && u_isspace(segment.GetSegmentText()[glyphsInfo[i].cluster]))
    {
        nextIndex(i);
    }
    return i;
}

void TextLib::Layout(const TextGenerationSettings& tgs)
{
    int xAdvance = 0;
    int firstGlyphIndex = 0;
    int lastGlyphIndex = 0;
    int lineGlyphIndexStart = -1;
    int minLineGlyphIndex = INT32_MAX;
    int maxLineGlyphIndex = INT32_MIN;
    int lineIndex = m_TextSegments.front().lineIndex;
    int wordWrapLineOffset = 0;
    bool justWrapped = false;

    auto glyphCount = m_TextShapingService.glyphCount;
    auto glyphsInfo = m_TextShapingService.glyphsInfo.data();
    auto glyphsPos = m_TextShapingService.glyphsPos.data();
    dynamic_array<TextSegment*> lineSegments;

    textInfo.textElementInfos.resize_initialized(glyphCount);

    for (auto& segment : m_TextSegments)
    {
        bool isRTL = segment.IsRTL();
        firstGlyphIndex = isRTL ? segment.firstGlyphIndex + segment.glyphCount - 1 : segment.firstGlyphIndex;
        lastGlyphIndex = isRTL ? segment.firstGlyphIndex : segment.firstGlyphIndex + segment.glyphCount;
        if (lineGlyphIndexStart == -1)
            lineGlyphIndexStart = firstGlyphIndex;

        // This segment is on a new line (\n)
        // Note that word wrap might have already caused a line break before this segment.
        auto lineOffset = justWrapped ? segment.lineIndex - lineIndex - 1 : segment.lineIndex - lineIndex;
        if (lineOffset > 0)
        {
            if (maxLineGlyphIndex > 0) // Only add newline if there is something to add
            {
                m_LineInfos.emplace_back(minLineGlyphIndex, maxLineGlyphIndex, lineIndex + wordWrapLineOffset, xAdvance,
                                         lineSegments);
                lineGlyphIndexStart = firstGlyphIndex;
                ResetLineValues(minLineGlyphIndex, maxLineGlyphIndex, lineSegments, xAdvance);
            }
            lineIndex = justWrapped ? segment.lineIndex - 1 : segment.lineIndex;
        }

        lineSegments.emplace_back(&segment);
        // TODO remove this lambda
        auto nextIndex = [&isRTL](int& i) { isRTL ? --i : ++i; };
        auto reachedEnd = [&isRTL, &lastGlyphIndex](int i) { return isRTL ? i >= lastGlyphIndex : i < lastGlyphIndex; };

        for (int i = firstGlyphIndex; reachedEnd(i); nextIndex(i))
        {
            justWrapped = false;
            if (xAdvance == 0 && u_isspace(segment.GetSegmentText()[glyphsInfo[i].cluster]))
                lineGlyphIndexStart = SkipWhiteSpaces(i, segment, nextIndex);

            minLineGlyphIndex = std::min(minLineGlyphIndex, i);
            maxLineGlyphIndex = std::max(maxLineGlyphIndex, i);
            auto glyphPos = glyphsPos[i];
            auto glyphInfo = glyphsInfo[i];

<<<<<<< Updated upstream
            xAdvance += glyphPos.x_advance;
=======
            // TODO hide 64.0f behind a method
            // Delay 64.0f division until the end to avoid precision loss
            xAdvance += glyphPos.x_advance / 64.0f;
>>>>>>> Stashed changes

            if (tgs.wrapText && xAdvance > tgs.GetScreenWidth())
            {
                int logicalBreakPointIndex = ComputeLogicalBreakPoint(i, lineGlyphIndexStart, segment, glyphInfo);

                // Remove segment if first glyph caused a line break and it is not the only segment in the line.
                if(lineSegments.size() > 1 && i == segment.firstGlyphIndex)
                    lineSegments.pop_back();

                // Roll back to the last safe break point that is not a whitespace.
                const auto* currentSegment = &segment;
                while (ShouldRollBack(i, lineGlyphIndexStart, logicalBreakPointIndex, glyphInfo, currentSegment))
                {
                    xAdvance -= glyphPos.x_advance;
                    if (currentSegment->IsRTL())
                    {
                        i++;
                        minLineGlyphIndex++;
                    }
                    else
                    {
                        i--;
                        maxLineGlyphIndex--;
                    }
                    glyphPos = glyphsPos[i];
                    glyphInfo = glyphsInfo[i];
                    currentSegment = FindSegmentByGlyphIndex(i);
                }

                m_LineInfos.emplace_back(minLineGlyphIndex, maxLineGlyphIndex, lineIndex + wordWrapLineOffset, xAdvance, lineSegments);
                lineGlyphIndexStart = isRTL ? i - 1 : i + 1;
                justWrapped = true;
                wordWrapLineOffset++;
                ResetLineValues(minLineGlyphIndex, maxLineGlyphIndex, lineSegments, xAdvance);

                // Segments can span on multiple lines, add current segment to the new line.
                if (i < segment.firstGlyphIndex + segment.glyphCount - 1)
                    lineSegments.emplace_back(&segment);
            }
            else if (IsLastGlyph(i, m_TextSegments.back()))
            {
                m_LineInfos.emplace_back(minLineGlyphIndex, maxLineGlyphIndex, lineIndex + wordWrapLineOffset, xAdvance, lineSegments);
            }
        }
    }

    const int totalHeight = CalculateTotalHeight(m_LineInfos, tgs);
    for(auto& lineInfo : m_LineInfos)
    {
        lineInfo.xOrigin = CalculateXOrigin(lineInfo, tgs);
        lineInfo.yOrigin = CalculateYOrigin(totalHeight, tgs);
        // TODO rename Alignment and Vertices Generation
        LayoutLine(lineInfo, tgs);
    }
}

int TextLib::CalculateTotalHeight(dynamic_array<LineInfo>& lineInfos, const TextGenerationSettings& tgs)
{
    int totalHeight = 0;
    int maxLineHeight = 0;
    int previousLineOffset = 0;

    for (int i = 0; i < lineInfos.size(); ++i)
    {
        auto& lineInfo = lineInfos[i];
        for (auto& segment : lineInfo.segments)
        {
            hb_font_extents_t fontExtents;
            hb_font_get_extents_for_direction(segment->GetHbFont(), segment->IsRTL() ? HB_DIRECTION_RTL : HB_DIRECTION_LTR , &fontExtents);

            lineInfo.maxAscender = std::max(lineInfo.maxAscender, fontExtents.ascender);
            lineInfo.minDescender = std::min(lineInfo.minDescender, fontExtents.descender);
            auto lineGap = (i < lineInfos.size() - 1) ? fontExtents.line_gap : 0;

            auto lineHeight = lineInfo.maxAscender - lineInfo.minDescender - lineGap;
            maxLineHeight = std::max(maxLineHeight, lineHeight);
        }

        int yOffsetForNewLines = 0;
        if (i + previousLineOffset < lineInfo.lineIndex)
        {
            yOffsetForNewLines = (lineInfo.lineIndex - i - previousLineOffset) * maxLineHeight;
            previousLineOffset += lineInfo.lineIndex - i;
        }

        if (tgs.verticalAlignment == VerticalAlignment::Top)
        {
            lineInfo.yAdvance = totalHeight + yOffsetForNewLines;
            totalHeight += maxLineHeight + yOffsetForNewLines;
        }
        else
        {
            totalHeight += maxLineHeight + yOffsetForNewLines;
            lineInfo.yAdvance = totalHeight;
        }
    }
    return totalHeight;
}

int TextLib::CalculateXOrigin(const LineInfo& lineInfo, const TextGenerationSettings& tgs)
{
    switch (tgs.horizontalAlignment)
    {
        case HorizontalAlignment::Center:
            return (tgs.GetScreenWidth() - lineInfo.lineWidth) * 0.5;
        case HorizontalAlignment::Right:
            return tgs.GetScreenWidth() - lineInfo.lineWidth;
        default: // Left alignment and other cases
            return 0;
    }
}

int TextLib::CalculateYOrigin(const int totalHeight, const TextGenerationSettings& tgs)
{
    switch (tgs.verticalAlignment)
    {
        case VerticalAlignment::Middle:
            return (tgs.GetScreenHeight() - totalHeight) * 0.5;
        case VerticalAlignment::Bottom:
            return tgs.GetScreenHeight() - totalHeight;
        default: // Top
            return 0;
    }
}

void TextLib::ApplyVerticalAlignment(Vector3f& vertex, const LineInfo& lineInfo, const TextGenerationSettings& tgs)
{
    switch (tgs.verticalAlignment)
    {
        case VerticalAlignment::Middle:
        case VerticalAlignment::Bottom:
            vertex.y = lineInfo.yOrigin + lineInfo.yAdvance - vertex.y + lineInfo.minDescender;
            break;
        default: // Top
            vertex.y = -vertex.y + lineInfo.yAdvance + lineInfo.maxAscender;
            break;
    }
}

void TextLib::LayoutLine(const LineInfo& lineInfo, const TextGenerationSettings& tgs)
{
    int xOrigin = lineInfo.xOrigin;
    for (auto& segment : lineInfo.segments)
    {
        int startIndex = std::max(segment->firstGlyphIndex, lineInfo.startGlyphIndex);
        int endIndex = std::min(segment->firstGlyphIndex + segment->glyphCount - 1, lineInfo.endGlyphIndex);
        for (int i = startIndex; i <= endIndex; ++i)
        {
            auto glyphPos = m_TextShapingService.glyphsPos[i];
            auto glyphInfo = m_TextShapingService.glyphsInfo[i];

            hb_glyph_extents_t extents;

            bool result = hb_font_get_glyph_extents(segment->GetHbFont(), glyphInfo.codepoint, &extents);
            if (!result)
                ErrorStringMsg("Failed to get glyph extents");

            int glyphWidth = extents.width;
            int glyphHeight = extents.height;
            int xBearing = extents.x_bearing;
            int yBearing = extents.y_bearing;

            int xOffset = glyphPos.x_offset;
            int yOffset = glyphPos.y_offset;

            // Mesh Generation in FreeType coordinate system
            
            float left = xOrigin + xBearing + xOffset;
            float right = xOrigin + xBearing + glyphWidth + xOffset;
            float bottom = glyphHeight + yBearing + yOffset;
            float top = yBearing + yOffset;

            Vector3f bottomLeft = Vector3f(left, bottom, 0);
            Vector3f topLeft = Vector3f(left, top, 0);
            Vector3f topRight = Vector3f(right, top, 0);
            Vector3f bottomRight = Vector3f(right, bottom, 0);

            // Convert to Unity coordinate system
            ApplyVerticalAlignment(bottomLeft, lineInfo, tgs);
            ApplyVerticalAlignment(topLeft, lineInfo, tgs);
            ApplyVerticalAlignment(topRight, lineInfo, tgs);
            ApplyVerticalAlignment(bottomRight, lineInfo, tgs);

            // We divide by 64 to get float precision instead of int
            textInfo.textElementInfos[i].bottomLeft = TextCoreVertex{bottomLeft / 64.0f, tgs.color, Vector2f{0, 0},
                                                                     Vector2f{0, 0}};
            textInfo.textElementInfos[i].topLeft = TextCoreVertex{topLeft / 64.0f, tgs.color, Vector2f{0, 0}, Vector2f{0, 0}};
            textInfo.textElementInfos[i].topRight = TextCoreVertex{topRight / 64.0f, tgs.color, Vector2f{0, 0}, Vector2f{0, 0}};
            textInfo.textElementInfos[i].bottomRight = TextCoreVertex{bottomRight / 64.0f, tgs.color, Vector2f{0, 0},
                                                                      Vector2f{0, 0}};

            textInfo.textElementInfos[i].glyphID = glyphInfo.codepoint;
            xOrigin += glyphPos.x_advance;
        }
    }
}

---TextUtilities.h---
#pragma once
#include <cstdint>

namespace TextUtilities
{
    const int ZWJ = 8205;

    bool IsHighSurrogate(uint16_t codeUnit) {
        return (codeUnit >= 0xD800 && codeUnit <= 0xDBFF);
    }

    bool IsLowSurrogate(uint16_t codeUnit) {
        return (codeUnit >= 0xDC00 && codeUnit <= 0xDFFF);
    }

    bool IsSurrogatePair(uint16_t highSurrogate, uint16_t lowSurrogate) {
        return IsHighSurrogate(highSurrogate) && IsLowSurrogate(lowSurrogate);
    }

    long SurrogatePairToCodePoint(uint16_t highSurrogate, uint16_t lowSurrogate) {
        return 0x10000 + ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00);
    }

    bool ShouldIgnoreUnicode(uint16_t unicode) {
        return unicode == ZWJ;
    }

    long GetUnicodeCodePoint(const uint16_t* segmentText, int index, int length, bool isRTL, bool& wasSurrogate)
    {
        long unicode = segmentText[index];
        if (ShouldIgnoreUnicode(unicode)) {
            isRTL ? index-- : index++;
        }
        if ((!isRTL && index < length - 1 && IsHighSurrogate(segmentText[index])) ||
            (isRTL && index > 0 && IsLowSurrogate(segmentText[index]))) {
            int lowSurrogateIndex = isRTL ? index : index + 1;
            int highSurrogateIndex = isRTL ? index - 1 : index;
            if (IsSurrogatePair(segmentText[highSurrogateIndex], segmentText[lowSurrogateIndex])) {
                unicode = SurrogatePairToCodePoint(segmentText[highSurrogateIndex],
                                                   segmentText[lowSurrogateIndex]);
                wasSurrogate = true;
            }
        }
        return unicode;
    }
}; // namespace TextUtilities

---MeshInfo.h---
#pragma once

#include "Runtime/Serialize/SerializeUtility.h"
#include "Runtime/Scripting/BindingsDefs.h"
#include "Runtime/Scripting/Marshalling/Marshalling.h"
#include "Runtime/Scripting/ScriptingArrayOf.h"
#include "Modules/TextCoreTextEngine/Native/TextCoreVertex.h"

struct MeshInfo
{
public:
    ScriptingArrayOf<TextCoreVertex> vertexData;
    ScriptingObjectPtr material;
    int vertexCount;

    template<class TransferFunc>
    inline void Transfer(TransferFunc& transfer)
    {
        transfer.Transfer(vertexCount, "vertexCount");
        transfer.Transfer(vertexData, "vertexData");
        transfer.Transfer(material, "material");
    }
};
BIND_MANAGED_TYPE_NAME(MeshInfo, UnityEngine_TextCore_Text_MeshInfoBindings);

---FontAsset.cpp---
#include "FontAsset.h"
#include <string>
#include <Modules/TextCoreFontEngine/Native/FontEngine.h>
#include <Modules/TextRendering/Public/Font.h>
#include <freetype/fttypes.h>
#include <freetype/freetype.h>
#include <hb-ft.h>
#include <Runtime/BaseClasses/EventManager.h>

FontAsset* FontAsset::GetFontAssetForUnicode(void* mainFontAsset, const dynamic_array<void*>& globalFontAssetFallbacks, const FontStyles fontStyle, const TextFontWeight fontWeight, const long unicode)
{
    FontAsset * fontAsset = nullptr;
    if (mainFontAsset != nullptr)
    {
        fontAsset = static_cast<FontAsset*>(mainFontAsset)->GetFontAssetWithFallbackForUnicode(fontStyle, fontWeight, unicode);
        if (fontAsset != nullptr)
            return fontAsset;
    }

    for (auto& fa : globalFontAssetFallbacks)
    {
        if(fa == nullptr)
            continue;

        fontAsset = static_cast<FontAsset*>(fa)->GetFontAssetWithFallbackForUnicode(fontStyle, fontWeight, unicode);
        if (fontAsset != nullptr)
            return fontAsset;
    }

    return static_cast<FontAsset*>(mainFontAsset);
}

FontAsset* FontAsset::GetFontAssetWithFallbackForUnicode(FontStyles fontStyle, TextFontWeight fontWeight, long unicode)
{
    FontAsset* resultFa = nullptr;

    FontAsset* temp = GetFontAssetWeightFallback(fontStyle, fontWeight);
    if (temp != nullptr && temp->fontInstanceID != 0)
    {
        resultFa = temp->GetFontAssetForUnicode(unicode);
        if (resultFa != nullptr)
            return resultFa;
    }

    resultFa = GetFontAssetForUnicode(unicode);
    if (resultFa != nullptr)
        return resultFa;

    for (auto& fallback : fallbackFontAssetTable)
    {
        resultFa = static_cast<FontAsset*>(fallback)->GetFontAssetWithFallbackForUnicode(fontStyle, fontWeight, unicode);
        if (resultFa != nullptr)
            return resultFa;
    }

    return nullptr;
}

FontAsset* FontAsset::GetFontAssetForUnicode(long unicode)
{
    FT_UInt result;
    if (!LoadFontFace())
        return nullptr;
    result = FT_Get_Char_Index(TextCore::FontEngine::GetCurrentFontFace(), unicode);
    if (result != 0)
        return this;
    return nullptr;
}

bool FontAsset::LoadFontFace(int fontSize) const
{
    // If sourceFontFile is provided, use it. Otherwise, use the sourceFontFilePath.
    if (sourceFontFile) {
        if (TextCore::FontEngine::LoadFontFace(sourceFontFile, fontSize) != 0) {
            WarningStringMsg("Unable to load font face from [%s]", sourceFontFile->GetName());
            return false;
        }
    }
    else if (sourceFontFilePath.length() > 0) {
        if (TextCore::FontEngine::LoadFontFace(sourceFontFilePath.c_str(), fontSize) != 0) {
            WarningStringMsg("Unable to load font face from [%s]", sourceFontFilePath.c_str());
            return false;
        }
    }
    #if UNITY_EDITOR
    else if (sourceFontFile_EditorRef) {
        if (TextCore::FontEngine::LoadFontFace(sourceFontFile_EditorRef, fontSize) != 0) {
            WarningStringMsg("Unable to load font face from [%s]", sourceFontFile_EditorRef->GetName());
            return false;
        }
    }
    #endif
    else if (faceInfo.familyName.length() > 0) {
        if (TextCore::FontEngine::LoadFontFace(faceInfo.familyName.c_str(), faceInfo.styleName.c_str(), fontSize) != 0) {
            // Here we do not send a warning message since the font is not provided by the user (OS font)
            return false;
        }
    }
    else {
        return false;
    }
    return true;
}

FontAsset* FontAsset::GetFontAssetWeightFallback(FontStyles fontStyle, TextFontWeight fontWeight)
{
    auto isItalic = (static_cast<int>(fontStyle) & static_cast<int>(FontStyles::Italic)) == static_cast<int>(FontStyles::Italic);

    int fontWeightIndex = 4;
    switch (fontWeight)
    {
        case TextFontWeight::Thin:
            fontWeightIndex = 1;
            break;
        case TextFontWeight::ExtraLight:
            fontWeightIndex = 2;
            break;
        case TextFontWeight::Light:
            fontWeightIndex = 3;
            break;
        case TextFontWeight::Regular:
            fontWeightIndex = 4;
            break;
        case TextFontWeight::Medium:
            fontWeightIndex = 5;
            break;
        case TextFontWeight::SemiBold:
            fontWeightIndex = 6;
            break;
        case TextFontWeight::Bold:
            fontWeightIndex = 7;
            break;
        case TextFontWeight::Heavy:
            fontWeightIndex = 8;
            break;
        case TextFontWeight::Black:
            fontWeightIndex = 9;
            break;
    }

    if ((!isItalic && fontWeightFallback.size() > fontWeightIndex) || (isItalic && fontWeightItalicFallback.size() > fontWeightIndex))
    {
        auto temp = static_cast<FontAsset*>(isItalic ? fontWeightItalicFallback[fontWeightIndex] : fontWeightFallback[fontWeightIndex]);

        if (temp != nullptr && temp->fontInstanceID != 0)
        {
            return temp;
        }
    }

    return nullptr;
}

hb_font_t* FontAsset::GetHbFontBySize(float fontSize)
{
    auto it = m_HbFontsPerSize.find(fontSize);

    // We need to load again even if it's cached to make sure we use the right size.
    if (!LoadFontFace(fontSize))
        return nullptr;

    if (it == m_HbFontsPerSize.end())
    {
        m_HbFontsPerSize[fontSize] = hb_ft_font_create_referenced(TextCore::FontEngine::GetCurrentFontFace());
        if (sourceFontFile.IsValid())
            sourceFontFile->AddEvent(FontDestroyedCallback, this);
        return m_HbFontsPerSize[fontSize];
    }
    else
    {
        return it->second;
    }
}

void FontAsset::ClearHbFonts()
{
    for (auto it = m_HbFontsPerSize.begin(); it != m_HbFontsPerSize.end(); ++it)
    {
        if (it->second) {
            hb_font_destroy(it->second);
        }
    }
    m_HbFontsPerSize.clear();
    if (sourceFontFile.IsValid() && sourceFontFile->HasEvent(FontDestroyedCallback, this))
        sourceFontFile->RemoveEvent(FontDestroyedCallback, this);
}

#if UNITY_EDITOR
void FontAsset::UpdateFontEditorRef(void* ptr, TextRendering::Font* sourceFontFile_EditorRef)
{
    FontAsset* cast_ptr = static_cast<FontAsset*>(ptr);
    cast_ptr->sourceFontFile_EditorRef = sourceFontFile_EditorRef;
}
#endif

void FontAsset::UpdateFallbacks(void* ptr, dynamic_array<void*> fallbackFontAssetTable)
{
    FontAsset* cast_ptr = static_cast<FontAsset*>(ptr);
    cast_ptr->fallbackFontAssetTable = fallbackFontAssetTable;
}

void FontAsset::UpdateWeightFallbacks(void* ptr, dynamic_array<void*> fontWeightFallback, dynamic_array<void*> fontWeightItalicFallback)
{
    FontAsset* cast_ptr = static_cast<FontAsset*>(ptr);
    cast_ptr->fontWeightFallback = fontWeightFallback;
    cast_ptr->fontWeightItalicFallback = fontWeightItalicFallback;
}

void* FontAsset::Create(TextCore::FaceInfo faceInfo, TextRendering::Font* sourceFontFile, TextRendering::Font* sourceFontFile_EditorRef, core::string sourceFontFilePath, int fontInstanceID, dynamic_array<void*> fallbackFontAssetTable, dynamic_array<void*> fontWeightFallback, dynamic_array<void*> fontWeightItalicFallback)
{
    FontAsset* fa = UNITY_NEW(FontAsset, kMemTextLib);
    fa->faceInfo = faceInfo;
    fa->sourceFontFile = sourceFontFile;
    fa->sourceFontFilePath = sourceFontFilePath;
    fa->fontInstanceID = fontInstanceID;
    fa->fallbackFontAssetTable = fallbackFontAssetTable;
    fa->fontWeightFallback = fontWeightFallback;
    fa->fontWeightItalicFallback = fontWeightItalicFallback;
    #if UNITY_EDITOR
    fa->sourceFontFile_EditorRef = sourceFontFile_EditorRef;
    #endif
    s_FontAssets.emplace_back(fa);

    if (!TextCore::FontEngine::CleanupFontEngineCallbacks.IsRegistered(&ClearAllHbFonts))
        TextCore::FontEngine::CleanupFontEngineCallbacks.Register(&ClearAllHbFonts);

    return fa;
}

void FontAsset::FontDestroyedCallback(void* userData, void* sender, int eventType)
{
    if (userData == nullptr)
        return;
    FontAsset* fa = static_cast<FontAsset*>(userData);;
    if (fa->sourceFontFile == sender) {
        fa->ClearHbFonts();
    }
}

void FontAsset::ClearAllHbFonts()
{
    for (auto fa : s_FontAssets) {
        fa->ClearHbFonts();
    }
}

void FontAsset::Destroy(void* ptr)
{
    FontAsset* cast_ptr = static_cast<FontAsset*>(ptr);
    cast_ptr->ClearHbFonts();
    TextCore::FontEngine::CleanupFontEngineCallbacks.Unregister(&ClearAllHbFonts);
    s_FontAssets.erase(std::remove(s_FontAssets.begin(), s_FontAssets.end(), cast_ptr), s_FontAssets.end());
    UNITY_DELETE(cast_ptr, kMemTextLib);
}

dynamic_array<FontAsset*> FontAsset::s_FontAssets;

---TextCoreVertex.h---
#pragma once

struct TextCoreVertex
{
public:
    Vector3f position;
    ColorRGBA32 color;
    Vector2f uv0;
    Vector2f uv2;

    template<class TransferFunc>
    inline void Transfer(TransferFunc& transfer)
    {
        transfer.Transfer(position, "position");
        transfer.Transfer(uv0, "uv0");
        transfer.Transfer(uv2, "uv2");
        transfer.Transfer(color, "color");
    }
};
BIND_MANAGED_TYPE_NAME(TextCoreVertex, UnityEngine_TextCore_Text_TextCoreVertex);

---TextSegment.h---
#pragma once

#include "FontAsset.h"

// HarfBuzz
#include <hb.h>

struct TextSegment {
    const char16_t* text; // Logical string
    int32_t start;
    int32_t length;
    int32_t lineIndex;
    int32_t fontSize;
    FontAsset* fontAsset;

    int32_t firstGlyphIndex;
	int32_t glyphCount;
    int32_t lastGlyphIndex;

    // Represent the nesting of different directionality types. Even numbers for left-to-right text (0, 2, 4...), odd numbers for right-to-left text (1, 3, 5...).
    uint8_t level;

    TextSegment(const char16_t* str, int32_t start, int32_t length, uint8_t level, int32_t lineIndex, int32_t fontSize, FontAsset* fontAsset, int32_t firstGlyphIndex = -1, int32_t lastGlyphIndex = -1)
            : text(str), start(start), length(length), level(level), lineIndex(lineIndex), fontSize(fontSize), fontAsset(fontAsset), firstGlyphIndex(firstGlyphIndex), lastGlyphIndex(lastGlyphIndex) {}

    TextSegment& operator=(const TextSegment& other)
    {
        if (this != &other)
        {
            text = other.text;
            start = other.start;
            length = other.length;
            level = other.level;
            lineIndex = other.lineIndex;
            fontSize = other.fontSize;
            fontAsset = other.fontAsset;
            firstGlyphIndex = other.firstGlyphIndex;
            glyphCount = other.glyphCount;
            lastGlyphIndex = other.lastGlyphIndex;
        }
        return *this;
    }

    inline const char16_t* GetSegmentText() const
    {
        return text + start;
    }

    inline const bool IsRTL() const
    {
        return level & 1;
    }

    inline hb_font_t* GetHbFont() const
    {
        return fontAsset->GetHbFontBySize(fontSize);
    }
};

---Tests/ICUServiceTests.cpp---
#include "UnityPrefix.h"
#if ENABLE_UNIT_TESTS && ENABLE_FAKING_SCRIPTS
#include "Runtime/Testing/Testing.h"
#include "TestUtils.h"

// ICU4C
// Init
#include <unicode/udata.h>

// BIDI
#include <unicode/utypes.h>
#include <unicode/ustring.h>

// Segmenter
#include <unicode/locid.h>

#if TEXT_RESSOURCE_AVAILABLE

UNIT_TEST_SUITE(ICUService)
{
    TEST_FIXTURE(GetNoICUFileFixture, LoadICUData_LoadsResourcesProperly)
    {
        ICUService icuService;

        // Load ICU data is already called by the constructor.
        CHECK_EQUAL(true, TestUtils::IsICUDataLoaded(icuService));
        CHECK(!TestUtils::IsICUDataEmpty(icuService));

        TestUtils::TerminateICU(icuService);

        CHECK_EQUAL(false, TestUtils::IsICUDataLoaded(icuService));
        CHECK(TestUtils::IsICUDataEmpty(icuService));
    }

    TEST_FIXTURE(GetNoICUFileFixture, BIDI_HandlesNewLine_Properly)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        tgs.text = "Hello\nWorld";

        dynamic_array<TextSegment> textSegments;

        ICUService icuService;
        icuService.Init(tgs);

        icuService.Bidi(tgs, textSegments);

        CHECK_EQUAL(2, textSegments.size());
    }

    TEST_FIXTURE(GetNoICUFileFixture, BidiService_AssignsCorrectLevelsAndParagraphsLTR)
    {
        TextGenerationSettings tgs;
        tgs.text = "אבגabc\nabcאבג";
        dynamic_array<TextSegment> textSegments;

        ICUService icuService;
        icuService.Init(tgs);

        // Default direction is LTR
        tgs.languageDirection = LanguageDirection::LTR;
        icuService.Bidi(tgs, textSegments);

        CHECK_EQUAL(4, textSegments.size());

        auto it = textSegments.begin();

        CHECK_EQUAL(it->level, 1);
        it++;

        CHECK_EQUAL(it->level, 0);
        it++;

        CHECK_EQUAL(it->level, 0);
        CHECK_EQUAL(it->lineIndex, 1);
        it++;

        CHECK_EQUAL(it->level, 1);
        CHECK_EQUAL(it->lineIndex, 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, BidiService_AssignsCorrectLevelsAndParagraphsRTL)
    {
        TextGenerationSettings tgs;
        tgs.text = "אבגabc\nabcאבג";
        dynamic_array<TextSegment> textSegments;

        ICUService icuService;
        icuService.Init(tgs);

        // Default direction is LTR
        tgs.languageDirection = LanguageDirection::RTL;
        icuService.Bidi(tgs, textSegments);

        CHECK_EQUAL(4, textSegments.size());

        auto it = textSegments.begin();

        CHECK_EQUAL(it->level, 0);
        it++;

        CHECK_EQUAL(it->level, 1);
        it++;

        CHECK_EQUAL(it->level, 1);
        CHECK_EQUAL(it->lineIndex, 1);
        it++;

        CHECK_EQUAL(it->level, 0);
        CHECK_EQUAL(it->lineIndex, 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, BidiService_AssignsCorrectOrder_LTR)
    {
        TextGenerationSettings tgs;
        tgs.text = "عربية and רית";
        dynamic_array<TextSegment> textSegments;

        ICUService icuService;
        icuService.Init(tgs);

        tgs.languageDirection = LanguageDirection::LTR;
        icuService.Bidi(tgs, textSegments);

        CHECK_EQUAL(3, textSegments.size());

        auto it = textSegments.begin();


        //عربية
        CHECK_EQUAL(it->level, 1);
        CHECK_EQUAL(it->length, 5);
        it++;

        // and
        CHECK_EQUAL(it->level, 0);
        CHECK_EQUAL(it->length, 5);
        it++;

        //רית
        CHECK_EQUAL(it->level, 1);
        CHECK_EQUAL(it->length, 3);
    }

    TEST_FIXTURE(GetNoICUFileFixture, BidiService_AssignsCorrectOrder_RTL)
    {
        TextGenerationSettings tgs;
        tgs.text = "عربية and רית";
        dynamic_array<TextSegment> textSegments;

        ICUService icuService;
        icuService.Init(tgs);

        tgs.languageDirection = LanguageDirection::RTL;
        icuService.Bidi(tgs, textSegments);

        CHECK_EQUAL(3, textSegments.size());

        auto it = textSegments.begin();

        // רית
        CHECK_EQUAL(it->level, 1);
        CHECK_EQUAL(it->length, 4);
        it++;

        //and
        CHECK_EQUAL(it->level, 0);
        CHECK_EQUAL(it->length, 3);
        it++;

         //عربية
        CHECK_EQUAL(it->level, 1);
        CHECK_EQUAL(it->length, 6);
    }

    TEST_FIXTURE(GetNoICUFileFixture, ICUService_IsInitialized_Properly)
    {
        TextGenerationSettings tgs;
        tgs.text = "Hello World";

        ICUService icuService;

        CHECK(icuService.wordBreakIterator == nullptr);
        CHECK(icuService.characterBreakIterator == nullptr);

        icuService.Init(tgs);

        CHECK(icuService.wordBreakIterator != nullptr);
        CHECK(icuService.characterBreakIterator != nullptr);
    }

    TEST_FIXTURE(GetNoICUFileFixture, ICUService_HandlesMultiParagraphs_Properly)
    {
        TextGenerationSettings tgs;
        tgs.text = "1\n\n2";
        dynamic_array<TextSegment> textSegments;

        ICUService icuService;
        icuService.Init(tgs);

        icuService.Bidi(tgs, textSegments);

        CHECK_EQUAL(2, textSegments.size());

        auto it = textSegments.begin();

        CHECK_EQUAL(it->lineIndex, 0);
        it++;

        CHECK_EQUAL(it->lineIndex, 2);
    }

    void TestLineEnding(const std::string& text, const std::vector<int>& expectedLineIndices, ICUService& icuService, TextGenerationSettings& tgs)
    {
        tgs.text = text;
        icuService.Init(tgs);

        dynamic_array<TextSegment> textSegments;
        icuService.Bidi(tgs, textSegments);

        CHECK_EQUAL(expectedLineIndices.size(), textSegments.size());

        for (size_t i = 0; i < expectedLineIndices.size(); ++i)
        {
            CHECK_EQUAL(expectedLineIndices[i], textSegments[i].lineIndex);
        }
    }

    TEST_FIXTURE(GetNoICUFileFixture, ICUService_HandlesAllLineEndings_Properly)
    {
        TextGenerationSettings tgs;
        ICUService icuService;

        // Test for line ending in the middle
        TestLineEnding("1\r\n2", {0, 1}, icuService, tgs);
        TestLineEnding("1\r2", {0, 1}, icuService, tgs);
        TestLineEnding("1\n2", {0, 1}, icuService, tgs);

        // Test for line ending at the beginning
        TestLineEnding("\r\n12345", {1}, icuService, tgs);
        TestLineEnding("\r12345", {1}, icuService, tgs);
        TestLineEnding("\n12345", {1}, icuService, tgs);

        TestLineEnding("\r\n\r\n12345", {2}, icuService, tgs);
        TestLineEnding("\r\r12345", {2}, icuService, tgs);
        TestLineEnding("\n\n12345", {2}, icuService, tgs);

        // Test for line ending at the end or line endings alone were not added as UITK always appends a zwsp at the end of the text.
    }
}

#endif //TEXT_RESOURCE_AVAILABLE
#endif

---Tests/TestUtils.h---
#pragma once

#include "UnityPrefix.h"
#if ENABLE_UNIT_TESTS 
#include "Runtime/Testing/Testing.h"
#include "../FontAsset.h"
#include "../TextGenerationSettings.h"
#include "../TextLib.h"
#include "../ICUService.h"


#if PLATFORM_WIN || PLATFORM_OSX || PLATFORM_IOS || PLATFORM_STANDALONE_WIN || PLATFORM_STANDALONE_OSX
#define TEXT_RESSOURCE_AVAILABLE 1
#endif

#if ENABLE_FAKING_SCRIPTS
#include "Runtime/Testing/Faking.h"
#include "Runtime/Testing/FakingScripts.h"

struct GetNoICUFileFixture : public TestFixtureWithScriptingSupport
{
    FAKE_STATIC_SCRIPT_METHOD(TextLib, LoadAndCountICUdata, int(ScriptingExceptionPtr*), "UnityEngine.TextCoreTextEngineModule.dll", "UnityEngine.TextCore.Text");
    FAKE_STATIC_SCRIPT_METHOD(TextLib, GetICUdata, bool(ScriptingSpan<UInt8> * , int), "UnityEngine.TextCoreTextEngineModule.dll", "UnityEngine.TextCore.Text");

    GetNoICUFileFixture()
    {
        TextLib_LoadAndCountICUdata.Returns(0);
        TextLib_GetICUdata.Returns(false);
    }
};
#endif

class TestUtils
{
public:
    static FontAsset* GetArialRegularDynamicOS();
    static FontAsset* GetDynamicOSWithoutArabicSupport();
    static FontAsset* GetDefaultEmojiFont();
    static FontAsset* GetDefaultLocalFallbackFont();
    static TextGenerationSettings GetDefaultTextGenerationSettings();
    static float GetDefaultLineHeight();
    static core::string DefaultLocalFallbackFamilyName;

    static bool IsICUDataLoaded(ICUService& icuService);
    static bool IsICUDataEmpty(ICUService& icuService);
    static void TerminateICU(ICUService& icuService);

    const static dynamic_array<TextSegment>* GetTextSegments(TextLib& textLib);
    const static dynamic_array<LineInfo>* GetLineInfos(TextLib& textLib);

private:
    static FontAsset ArialRegularDynamicOS;
    static bool IsArialRegularDynamicOSInitialized;

    static FontAsset LucidaConsoleRegularDynamicOS;
    static bool IsLucidaConsoleRegularDynamicOSInitialized;

    static FontAsset DefaultEmojiFont;
    static bool IsDefaultEmojiFontInitialized;

    static FontAsset DefaultLocalFallbackFont;
    static bool IsDefaultLocalFallbackFontInitialized;
};

#define GET_DEFAULT_TGS_OR_RETURN() \
    TestUtils::GetDefaultTextGenerationSettings(); \
    if (tgs.fontAsset == nullptr) \
    { \
        CHECK(false); \
        return; \
    }


#define CHECK_EQUALS_OR_RETURN(expected, actual) \
    do{\
        CHECK_EQUAL(expected, actual); \
        if (expected != actual) \
        { \
            CHECK(false); \
            return; \
        } \
    } while(0)

#define CHECK_GREATER_THAN_OR_RETURN(expected, actual) \
    do{\
        if (expected > actual) \
        { \
            CHECK(false); \
            return; \
        } \
    } while(0)

#endif

---Tests/TextShapingServiceTests.cpp---
#include "UnityPrefix.h"
#if ENABLE_UNIT_TESTS && ENABLE_FAKING_SCRIPTS
#include "Runtime/Testing/Testing.h"
#include "../TextShapingService.h"
#include "TestUtils.h"

using namespace TestAttributes;

#if TEXT_RESSOURCE_AVAILABLE

UNIT_TEST_SUITE(TextShapingService)
{
    TEST(ShapeService_PopulatesGlyphs_Properly)
    {
        auto* logicalStr = (char16_t*)u"Hello World";
        int32_t length = 11;

        TextShapingService tss;
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        if (tgs.fontAsset == nullptr)
        {
            CHECK(false);
            return;
        }

        dynamic_array<TextSegment> textSegments;
        TextSegment seg = TextSegment(logicalStr, 0, length, 0, 0, tgs.fontSize, (FontAsset*)tgs.fontAsset, 0);
        textSegments.emplace_back(seg);


        TextInfo textInfo;
        textInfo.fontAssetIds.resize_uninitialized(textSegments.size());
        textInfo.fontAssetLastGlyphIndex.resize_uninitialized(textSegments.size());

        tss.Shape(textInfo, textSegments);

        CHECK_EQUAL(length, tss.glyphCount);
    }
}
#endif //TEXT_RESOURCE_AVAILABLE
#endif

---Tests/TextLayoutTests.cpp---
#include "UnityPrefix.h"
#if ENABLE_UNIT_TESTS && ENABLE_FAKING_SCRIPTS
#include "Runtime/Testing/Testing.h"
#include "../TextLib.h"
#include "TestUtils.h"

#if TEXT_RESSOURCE_AVAILABLE

UNIT_TEST_SUITE(TextLayout)
{
    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapWords_Properly)
    {
        // Should result in:
        // |1|
        // |2| Notice the spaces are stripped.
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        tgs.text = "1 2";
        tgs.wrapText = true;
        tgs.screenWidth = 19 << 6;
        tgs.screenHeight = 49 << 6;
        tgs.fontSize = 14;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_EQUALS_OR_RETURN(2, lineInfosCount);
        CHECK_EQUAL(2, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapsCharacters_Properly)
    {
        // Should result in:
        // |1|
        // |2|
        // |3|
        // |4|
        // |5|
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        tgs.text = "12345";
        tgs.wrapText = true;
        tgs.screenWidth = 0;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(5, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    // Should result in:
    // |123|
    // |123|
    // |4  |
    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapSecondLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        tgs.text = "123\n1234";
        tgs.wrapText = true;
        tgs.screenWidth = 26 << 6;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_GREATER_THAN_OR_RETURN(3, lineInfosCount);
        CHECK_EQUAL(3, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);

        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(0, (*lineInfos)[0].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(3, (*lineInfos)[1].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(6, (*lineInfos)[2].startGlyphIndex);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapsMultipleSegments_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "L수m";
        tgs.wrapText = true;

        // Wrap last character: "m"
        tgs.screenWidth = 27 << 6;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);

        CHECK_GREATER_THAN_OR_RETURN(2, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(TestUtils::DefaultLocalFallbackFamilyName, (*lineInfos)[0].segments[1]->fontAsset->faceInfo.familyName);
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());

        // Wrap character: "수"
        tgs.screenWidth = 17 << 6;
        textLib.GenerateText(tgs);

        lineInfosCount = (*lineInfos).size();
        CHECK_EQUALS_OR_RETURN(3, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);

        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());

        // Wrap all
        tgs.screenWidth = 0;
        textLib.GenerateText(tgs);

        lineInfosCount = (*lineInfos).size();
        CHECK_EQUALS_OR_RETURN(3, lineInfosCount);
        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());
    }

    TEST_FIXTURE(GetNoICUFileFixture, WordWrapping_WithRTL_WorksProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "\"العربية هي لغة جميلة\""; // This translates to: "Arabic is a beautiful language"
        tgs.wrapText = true;
        tgs.languageDirection = LanguageDirection::RTL;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(1, (*lineInfos).size());

        // Should result in the first word wrapping:
        // |العربية هي لغة|
        // |         جميلة|
        tgs.screenWidth = 80 << 6;
        textLib.GenerateText(tgs);

        CHECK_EQUAL(2, (*lineInfos).size());
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesNewLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello\nWorld";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos).size());
        CHECK_EQUAL(0, (*lineInfos)[0].xOrigin);
        CHECK_EQUAL(0, (*lineInfos)[1].xOrigin);
        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_WithRTLHandlesNewLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "مرحبًا،\nتعمل؟"; // This translates to: Hello,\nWorks?
        tgs.languageDirection = LanguageDirection::RTL;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos).size());
        CHECK_EQUAL(7, (*lineInfos)[0].segments[0]->glyphCount);
        CHECK_EQUAL(5, (*lineInfos)[1].segments[0]->glyphCount);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesMultiParagraph_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.verticalAlignment = VerticalAlignment::Bottom;
        tgs.text = "Hello\n\n\nWorld";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_NewLinesAtBeginingOfText_AreHandledProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.verticalAlignment = VerticalAlignment::Bottom;
        tgs.text = "\n\n\nHello World";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
        CHECK_EQUAL(TestUtils::GetDefaultLineHeight() * 4, (*lineInfos)[0].yAdvance);

        CHECK_EQUAL(0, (*lineInfos)[0].startGlyphIndex);
        CHECK_EQUAL(10, (*lineInfos)[0].endGlyphIndex);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesNewlineWithWordWrap_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        // Should result in
        // |123|
        // |4  |
        // |123|
        tgs.text = "1234\n123";
        tgs.wrapText = true;
        tgs.screenWidth = 26 << 6;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(3, lineInfosCount);
        CHECK_EQUAL(3, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(0, (*lineInfos)[0].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(3, (*lineInfos)[1].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(4, (*lineInfos)[2].startGlyphIndex);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesNewLineWithCharacterWordWrap_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        TextLib textLib;

        // Should result in
        // |1|
        // |2|
        // | |
        // |3|
        tgs.text = "12\n\n3";
        tgs.wrapText = true;
        tgs.screenWidth = 0;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);

        CHECK_EQUAL(3, lineInfosCount);
        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesMultipleNewLineWithCharacterWordWrap_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        TextLib textLib;

        // Should result in
        // |12|
        // |  |
        // |12|
        // |3|
        tgs.text = "12\n\n123";
        tgs.wrapText = true;
        tgs.screenWidth = 17 << 6;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_IgnoresWhiteSpacesAtBeginingAndEndOfLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "1     2     ";
        tgs.screenWidth = 10 << 6;
        tgs.wrapText = true;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(2, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_TopLeft_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Top;
        tgs.horizontalAlignment = HorizontalAlignment::Left;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        auto lineInfo = (*lineInfos)[0];


        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_EQUAL(0, lineInfo.xOrigin);
        CHECK_EQUAL(0, lineInfo.yAdvance);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_CenterAlignment_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Middle;
        tgs.horizontalAlignment = HorizontalAlignment::Center;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);

        auto lineInfo = (*lineInfos)[0];

        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_EQUAL(tgs.screenWidth / 2, lineInfo.xOrigin + lineInfo.lineWidth / 2);
        CHECK_EQUAL(tgs.screenHeight / 2, lineInfo.yOrigin + lineInfo.yAdvance / 2);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_RightTopAlignment_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Top;
        tgs.horizontalAlignment = HorizontalAlignment::Right;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        auto lineInfo = (*lineInfos)[0];

        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_EQUAL(tgs.screenWidth - lineInfo.lineWidth, lineInfo.xOrigin);
        CHECK_EQUAL(0, lineInfo.yAdvance);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_RightTopAlignWithWordWrapAndRTL_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "\"العربية هي لغة جميلة\""; // This translates to: "Arabic is a beautiful language"
        tgs.wrapText = true;
        tgs.verticalAlignment = VerticalAlignment::Top;
        tgs.horizontalAlignment = HorizontalAlignment::Right;
        tgs.languageDirection = LanguageDirection::RTL;
        tgs.screenWidth = 80 << 6;

        // Should result in:
        // |العربية هي لغة|
        // |جميلة         |
        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos).size());

        auto firstLineInfo = (*lineInfos)[0];
        CHECK_EQUAL(tgs.screenWidth - firstLineInfo.lineWidth, firstLineInfo.xOrigin);

        auto lastLineInfo = (*lineInfos)[1];
        CHECK_EQUAL(tgs.screenWidth - lastLineInfo.lineWidth, lastLineInfo.xOrigin);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_LeftBottomAlignment_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Bottom;
        tgs.horizontalAlignment = HorizontalAlignment::Left;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        auto lineInfo = (*lineInfos)[0];

        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_EQUAL(0, lineInfo.xOrigin);
        CHECK_EQUAL(tgs.screenWidth, lineInfo.yOrigin + lineInfo.yAdvance);
    }
}
#endif //TEXT_RESOURCE_AVAILABLE
#endif

---Tests/TextLibTests.cpp---
#include "UnityPrefix.h"
#if ENABLE_UNIT_TESTS && ENABLE_FAKING_SCRIPTS
#include "Runtime/Testing/Testing.h"
#include "../TextLib.h"
#include "TestUtils.h"
#include "Runtime/Testing/Faking.h"

#if TEXT_RESSOURCE_AVAILABLE

using namespace testing;
UNIT_TEST_SUITE(TextLib)
{
    TEST_FIXTURE(GetNoICUFileFixture, GenerateText_SanityCheck)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();

        TextLib textLib;
        textLib.GenerateText(tgs);

        CHECK_EQUAL(11, textLib.textInfo.textElementInfos.size());
        CHECK_EQUAL(1, textLib.textInfo.fontAssetIds.size());
    }

    TEST_FIXTURE(GetNoICUFileFixture, GenerateText_WhenCalledTwice_UpdatesTextInfoProperly)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        tgs.text = "123";

        TextLib textLib;
        textLib.GenerateText(tgs);

        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());
        CHECK_EQUAL(20, textLib.textInfo.textElementInfos[0].glyphID);
        CHECK_EQUAL(21, textLib.textInfo.textElementInfos[1].glyphID);
        CHECK_EQUAL(22, textLib.textInfo.textElementInfos[2].glyphID);

        tgs.text = "456";
        textLib.GenerateText(tgs);

        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());
        CHECK_EQUAL(23, textLib.textInfo.textElementInfos[0].glyphID);
        CHECK_EQUAL(24, textLib.textInfo.textElementInfos[1].glyphID);
        CHECK_EQUAL(25, textLib.textInfo.textElementInfos[2].glyphID);
    }

    TEST_FIXTURE(GetNoICUFileFixture, GenerateText_HandlesFallbacks_Properly)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        tgs.text = "L수m";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto textSegments = TestUtils::GetTextSegments(textLib);
        CHECK_EQUAL(3, textSegments->size());
        auto seg = (*textSegments).begin();
        CHECK_EQUAL("Arial", seg->fontAsset->faceInfo.familyName);
        seg++;
        CHECK_EQUAL(TestUtils::DefaultLocalFallbackFamilyName, seg->fontAsset->faceInfo.familyName);
        seg++;
        CHECK_EQUAL("Arial", seg->fontAsset->faceInfo.familyName);
    }

    TEST_FIXTURE(GetNoICUFileFixture, GenerateText_HandlesItalicFallback_Properly)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        ((FontAsset*)tgs.fontAsset)->fontWeightItalicFallback.push_back((void*)TestUtils::GetDefaultLocalFallbackFont());
        ((FontAsset*)tgs.fontAsset)->fontWeightItalicFallback.push_back((void*)TestUtils::GetDefaultLocalFallbackFont());
        ((FontAsset*)tgs.fontAsset)->fontWeightItalicFallback.push_back((void*)TestUtils::GetDefaultLocalFallbackFont());
        ((FontAsset*)tgs.fontAsset)->fontWeightItalicFallback.push_back((void*)TestUtils::GetDefaultLocalFallbackFont());
        ((FontAsset*)tgs.fontAsset)->fontWeightItalicFallback.push_back((void*)TestUtils::GetDefaultLocalFallbackFont());
        tgs.text = "Italic";
        tgs.fontStyle = FontStyles::Italic;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto textSegments = TestUtils::GetTextSegments(textLib);
        CHECK_EQUAL(1, textSegments->size());
        auto seg = textSegments->begin();
        CHECK_EQUAL(TestUtils::DefaultLocalFallbackFamilyName, seg->fontAsset->faceInfo.familyName);
    }

    TEST_FIXTURE(GetNoICUFileFixture, GenerateText_WithComplexEmoji_GenerateTextProperly)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        tgs.fontAsset = TestUtils::GetDefaultEmojiFont();
        tgs.text = "👨‍👩‍👧‍👦";

        TextLib textLib;
        textLib.GenerateText(tgs);
        auto expectedGlyphCount = 4;
#if PLATFORM_OSX
        expectedGlyphCount = 1;
#endif
        auto textSegments = TestUtils::GetTextSegments(textLib);
        CHECK_EQUAL(1, textSegments->size());
        auto seg = textSegments->begin();
        CHECK_EQUAL(expectedGlyphCount, seg->glyphCount);
    }

    TEST_FIXTURE(GetNoICUFileFixture, GenerateText_WithRTL_GenerateSegmentsProperly_LTR)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        tgs.languageDirection = LanguageDirection::LTR;
        tgs.text = "عربية and רית";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto textSegments = TestUtils::GetTextSegments(textLib);
        CHECK_EQUAL(3, textSegments->size());

        auto seg = textSegments->begin();
        //عربية
        CHECK_EQUAL(5, seg->glyphCount);
        seg++;

        // and 
        CHECK_EQUAL(5, seg->glyphCount);
        seg++;

        //רית
        CHECK_EQUAL(3, seg->glyphCount);
    }

    TEST_FIXTURE(GetNoICUFileFixture, GenerateText_WithRTL_GenerateSegmentsProperly_RTL)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        tgs.languageDirection = LanguageDirection::RTL;
        // To make sure space and "and" are not in the same font asset as the arabic characters
        tgs.fontAsset = TestUtils::GetDynamicOSWithoutArabicSupport();
        tgs.globalFontAssetFallbacks.push_back(TestUtils::GetArialRegularDynamicOS());
        tgs.text = "عربية and רית";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto textSegments = TestUtils::GetTextSegments(textLib);
        CHECK_EQUAL(5, textSegments->size());

        auto seg = textSegments->begin();
        //רית
        CHECK_EQUAL(3, seg->glyphCount);
        seg++;

        //[space]
        CHECK_EQUAL(1, seg->glyphCount);
        seg++;

        //and
        CHECK_EQUAL(3, seg->glyphCount);
        seg++;

        //[space]
        CHECK_EQUAL(1, seg->glyphCount);
        seg++;

        //عربية
        CHECK_EQUAL(5, seg->glyphCount);
    }
}

#endif // TEXT_RESSOURCE_AVAILABLE

#endif



---Tests/TextLayoutTests.cpp.orig---
#include "UnityPrefix.h"
#if ENABLE_UNIT_TESTS && ENABLE_FAKING_SCRIPTS
#include "Runtime/Testing/Testing.h"
#include "../TextLib.h"
#include "TestUtils.h"

#if TEXT_RESSOURCE_AVAILABLE

UNIT_TEST_SUITE(TextLayout)
{
    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapWords_Properly)
    {
        // Should result in:
        // |1|
        // |2| Notice the spaces are stripped.
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        tgs.text = "1 2";
        tgs.wrapText = true;
        tgs.screenWidth = 19;
        tgs.screenHeight = 49;
        tgs.fontSize = 14;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_EQUALS_OR_RETURN(2, lineInfosCount);
        CHECK_EQUAL(2, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapsCharacters_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        tgs.text = "12345";
        tgs.wrapText = true;
        tgs.screenWidth = 0;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(5, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    // Should result in:
    // |123|
    // |123|
    // |4  |
    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapSecondLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        tgs.text = "123\n1234";
        tgs.wrapText = true;
        tgs.screenWidth = 26;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_GREATER_THAN_OR_RETURN(3, lineInfosCount);
        CHECK_EQUAL(3, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);

        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(0, (*lineInfos)[0].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(3, (*lineInfos)[1].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(6, (*lineInfos)[2].startGlyphIndex);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_WordWrapsMultipleSegments_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "L수m";
        tgs.wrapText = true;

        // Wrap last character: "m"
        tgs.screenWidth = 27;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = lineInfos->size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);

        CHECK_GREATER_THAN_OR_RETURN(2, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(TestUtils::DefaultLocalFallbackFamilyName, (*lineInfos)[0].segments[1]->fontAsset->faceInfo.familyName);
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());

        // Wrap character: "수"
        tgs.screenWidth = 17;
        textLib.GenerateText(tgs);

        lineInfosCount = (*lineInfos).size();
        CHECK_EQUALS_OR_RETURN(3, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);

        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());

        // Wrap all
        tgs.screenWidth = 0;
        textLib.GenerateText(tgs);

        lineInfosCount = (*lineInfos).size();
        CHECK_EQUALS_OR_RETURN(3, lineInfosCount);
        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(3, textLib.textInfo.textElementInfos.size());
    }

    TEST_FIXTURE(GetNoICUFileFixture, WordWrapping_WithRTL_WorksProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "\"العربية هي لغة جميلة\""; // This translates to: "Arabic is a beautiful language"
        tgs.wrapText = true;
        tgs.languageDirection = LanguageDirection::RTL;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(1, (*lineInfos).size());

        // Should result in the first word wrapping:
        // |العربية هي لغة|
        // |         جميلة|
        tgs.screenWidth = 80;
        textLib.GenerateText(tgs);

<<<<<<< Updated upstream
        CHECK_EQUAL(2, (*lineInfos).size());
=======
        CHECK_EQUAL(2, textLib.lineInfos.size());
        CHECK_EQUAL(0, textLib.lineInfos[0].xOrigin);
        CHECK_EQUAL(7, textLib.lineInfos[0].startGlyphIndex);
        CHECK_EQUAL(21, textLib.lineInfos[0].endGlyphIndex);
        CHECK_EQUAL(0, textLib.lineInfos[1].xOrigin);
        CHECK_EQUAL(0, textLib.lineInfos[1].startGlyphIndex);
        CHECK_EQUAL(5, textLib.lineInfos[1].endGlyphIndex); // We skip one space character
    }

    TEST_FIXTURE(GetNoICUFileFixture, WordWrapping_WithBIDI_WorksProperly)
    {
        TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
        tgs.text = "אבג 12";
        tgs.languageDirection = LanguageDirection::RTL;
        tgs.wrapText = true;

        TextLib textLib;
        textLib.GenerateText(tgs);

        CHECK_EQUAL(1, textLib.lineInfos.size());

        // Should result in:
        // |12|
        // |אבג|
        tgs.screenWidth = 31;
        textLib.GenerateText(tgs);

        CHECK_EQUAL(2, textLib.lineInfos.size());
>>>>>>> Stashed changes
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesNewLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello\nWorld";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos).size());
        CHECK_CLOSE(0.0f, (*lineInfos)[0].xOrigin, 0.01f);
        CHECK_CLOSE(0.0f, (*lineInfos)[1].xOrigin, 0.01f);
        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_WithRTLHandlesNewLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "مرحبًا،\nتعمل؟"; // This translates to: Hello,\nWorks?
        tgs.languageDirection = LanguageDirection::RTL;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos).size());
        CHECK_EQUAL(7, (*lineInfos)[0].segments[0]->glyphCount);
        CHECK_EQUAL(5, (*lineInfos)[1].segments[0]->glyphCount);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesMultiParagraph_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.verticalAlignment = VerticalAlignment::Bottom;
        tgs.text = "Hello\n\n\nWorld";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_NewLinesAtBeginingOfText_AreHandledProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.verticalAlignment = VerticalAlignment::Bottom;
        tgs.text = "\n\n\nHello World";

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
        CHECK_EQUAL(TestUtils::GetDefaultLineHeight() * 4, (*lineInfos)[0].yAdvance);

        CHECK_EQUAL(0, (*lineInfos)[0].startGlyphIndex);
        CHECK_EQUAL(10, (*lineInfos)[0].endGlyphIndex);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesNewlineWithWordWrap_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()

        // Should result in
        // |123|
        // |4  |
        // |123|
        tgs.text = "1234\n123";
        tgs.wrapText = true;
        tgs.screenWidth = 26;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(3, lineInfosCount);
        CHECK_EQUAL(3, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
        CHECK_EQUAL(1, (*lineInfos)[0].segments.size());
        CHECK_EQUAL(0, (*lineInfos)[0].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[1].segments.size());
        CHECK_EQUAL(3, (*lineInfos)[1].startGlyphIndex);

        CHECK_EQUAL(1, (*lineInfos)[2].segments.size());
        CHECK_EQUAL(4, (*lineInfos)[2].startGlyphIndex);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesNewLineWithCharacterWordWrap_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        TextLib textLib;

        // Should result in
        // |1|
        // |2|
        // | |
        // |3|
        tgs.text = "12\n\n3";
        tgs.wrapText = true;
        tgs.screenWidth = 0;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);

        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_HandlesMultipleNewLineWithCharacterWordWrap_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        TextLib textLib;

        // Should result in
        // |12|
        // |  |
        // |12|
        // |3|
        tgs.text = "12\n\n123";
        tgs.wrapText = true;
        tgs.screenWidth = 17;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(4, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, Layout_IgnoresWhiteSpacesAtBeginingAndEndOfLine_Properly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "1     2     ";
        tgs.screenWidth = 10;
        tgs.wrapText = true;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        CHECK_EQUAL(2, (*lineInfos)[lineInfosCount - 1].lineIndex + 1);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_TopLeft_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Top;
        tgs.horizontalAlignment = HorizontalAlignment::Left;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        auto lineInfo = (*lineInfos)[0];


        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_EQUAL(0, lineInfo.xOrigin);
        CHECK_EQUAL(0, lineInfo.yAdvance);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_CenterAlignment_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Middle;
        tgs.horizontalAlignment = HorizontalAlignment::Center;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);

        auto lineInfo = (*lineInfos)[0];

        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_CLOSE(tgs.screenWidth / 2.0, lineInfo.xOrigin + lineInfo.lineWidth / 2.0, 0.01);
        CHECK_CLOSE(tgs.screenHeight / 2.0, lineInfo.yOrigin + lineInfo.yAdvance / 2.0, 0.01);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_RightTopAlignment_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Top;
        tgs.horizontalAlignment = HorizontalAlignment::Right;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        auto lineInfo = (*lineInfos)[0];

        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_EQUAL(tgs.screenWidth - lineInfo.lineWidth, lineInfo.xOrigin);
        CHECK_EQUAL(0, lineInfo.yAdvance);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_RightTopAlignWithWordWrapAndRTL_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "\"العربية هي لغة جميلة\""; // This translates to: "Arabic is a beautiful language"
        tgs.wrapText = true;
        tgs.verticalAlignment = VerticalAlignment::Top;
        tgs.horizontalAlignment = HorizontalAlignment::Right;
        tgs.languageDirection = LanguageDirection::RTL;
        tgs.screenWidth = 80;

        // Should result in:
        // |العربية هي لغة|
        // |جميلة         |
        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        CHECK_EQUALS_OR_RETURN(2, (*lineInfos).size());

        auto firstLineInfo = (*lineInfos)[0];
        CHECK_EQUAL(tgs.screenWidth - firstLineInfo.lineWidth, firstLineInfo.xOrigin);

        auto lastLineInfo = (*lineInfos)[1];
        CHECK_EQUAL(tgs.screenWidth - lastLineInfo.lineWidth, lastLineInfo.xOrigin);
    }

    TEST_FIXTURE(GetNoICUFileFixture, TextAlignment_LeftBottomAlignment_IsPositionedProperly)
    {
        TextGenerationSettings tgs = GET_DEFAULT_TGS_OR_RETURN()
        tgs.text = "Hello World";
        tgs.verticalAlignment = VerticalAlignment::Bottom;
        tgs.horizontalAlignment = HorizontalAlignment::Left;

        TextLib textLib;
        textLib.GenerateText(tgs);

        auto lineInfos = TestUtils::GetLineInfos(textLib);
        auto lineInfosCount = (*lineInfos).size();
        CHECK_GREATER_THAN_OR_RETURN(1, lineInfosCount);
        auto lineInfo = (*lineInfos)[0];

        CHECK_EQUAL(1, (*lineInfos).size());
        CHECK_EQUAL(0, lineInfo.xOrigin);
        CHECK_EQUAL(tgs.screenHeight, lineInfo.yOrigin + lineInfo.yAdvance);
    }
}
#endif //TEXT_RESOURCE_AVAILABLE
#endif

---Tests/TestUtils.cpp---
#include "UnityPrefix.h"
#if ENABLE_UNIT_TESTS
#include "Runtime/Testing/Testing.h"
#include "TestUtils.h"


core::string GetPlatformEmojiFamilyName()
{
#if PLATFORM_WIN || PLATFORM_GAMECORE_SCARLETT ||PLATFORM_STANDALONE_WIN 
    return "Segoe UI Emoji";
#elif PLATFORM_OSX || PLATFORM_IOS || PLATFORM_STANDALONE_OSX
    return "Apple Color Emoji";
#else
    return "Noto Color Emoji";
#endif
}

core::string GetPlatformFallbackFamilyName()
{
#if PLATFORM_WIN || PLATFORM_GAMECORE_SCARLETT || PLATFORM_STANDALONE_WIN
    return "Malgun Gothic";
#elif PLATFORM_OSX || PLATFORM_IOS || PLATFORM_STANDALONE_OSX
    return "Arial Unicode MS";
#elif PLATFORM_LINUX
    return "Noto Sans Mono CJK SC";
#else
    return "Arial Unicode MS";
#endif
}

core::string GetFamilyNameWithoutArabicSupport()
{
#if PLATFORM_WIN || PLATFORM_GAMECORE_SCARLETT || PLATFORM_STANDALONE_WIN
    return "Lucida Console";
#elif PLATFORM_OSX || PLATFORM_IOS || PLATFORM_STANDALONE_OSX
    return "Impact";
#else
    return "??";
#endif
}

TextGenerationSettings TestUtils::GetDefaultTextGenerationSettings()
{
    TextGenerationSettings tgs;
    tgs.text = "Hello World";
    tgs.fontAsset = GetArialRegularDynamicOS();
    tgs.screenHeight = 100 * 64;
    tgs.screenWidth = 100 * 64;
    tgs.fontSize = 12;
    tgs.wrapText = false;
    tgs.verticalAlignment = VerticalAlignment::Top;
    tgs.horizontalAlignment = HorizontalAlignment::Left;
    tgs.languageDirection = LanguageDirection::LTR;

    return tgs;
}

FontAsset TestUtils::ArialRegularDynamicOS;
bool TestUtils::IsArialRegularDynamicOSInitialized = false;
bool ErrorDuringArialInitialization = false;

FontAsset* TestUtils::GetArialRegularDynamicOS()
{
    bool error = false;
    if (!IsArialRegularDynamicOSInitialized)
    {
#if PLATFORM_LINUX
        ArialRegularDynamicOS.faceInfo.familyName = "URW Gothic L";
#else
        ArialRegularDynamicOS.faceInfo.familyName = "Arial";
#endif

        ArialRegularDynamicOS.faceInfo.styleName = "Regular";

        // check if the main font has the glyph for 'A' before adding the fallback font
        error = ArialRegularDynamicOS.GetFontAssetForUnicode('A') == nullptr;
        CHECK_MSG(!error, "The main font does not contain the glyph for 'A'");

        bool mainFontContainsFallbackChar = ArialRegularDynamicOS.GetFontAssetForUnicode(U'수') != nullptr;
        CHECK_MSG(!mainFontContainsFallbackChar, "The main font contains the glyph for '수'");
        error = error || mainFontContainsFallbackChar;

        //tests that the fallback contains the glyph for '수' and add it to the fallback list
        auto fallback = GetDefaultLocalFallbackFont();
        bool fallbackContainsChar = fallback->GetFontAssetForUnicode(U'수') != nullptr;
        CHECK_MSG(fallbackContainsChar, Format("The fallback font (%s) does not contain the glyph for '수'", fallback->faceInfo.familyName.c_str() ).c_str() );
        error = error || !fallbackContainsChar;

        ArialRegularDynamicOS.fallbackFontAssetTable.push_back(fallback);

        IsArialRegularDynamicOSInitialized = true;
        ErrorDuringArialInitialization = error;
    }

    if (ErrorDuringArialInitialization)
        return nullptr;

    return &ArialRegularDynamicOS;
}


FontAsset TestUtils::LucidaConsoleRegularDynamicOS;
bool TestUtils::IsLucidaConsoleRegularDynamicOSInitialized = false;

FontAsset* TestUtils::GetDynamicOSWithoutArabicSupport()
{
    if (!IsLucidaConsoleRegularDynamicOSInitialized)
    {
        LucidaConsoleRegularDynamicOS.faceInfo.familyName = GetFamilyNameWithoutArabicSupport();
        LucidaConsoleRegularDynamicOS.faceInfo.styleName = "Regular";
        IsLucidaConsoleRegularDynamicOSInitialized = true;
    }

    return &LucidaConsoleRegularDynamicOS;
}

FontAsset TestUtils::DefaultEmojiFont;
bool TestUtils::IsDefaultEmojiFontInitialized = false;

FontAsset* TestUtils::GetDefaultEmojiFont()
{
    if (!IsDefaultEmojiFontInitialized)
    {
        DefaultEmojiFont.faceInfo.familyName = GetPlatformEmojiFamilyName();
        DefaultEmojiFont.faceInfo.styleName = "Regular";
        IsDefaultEmojiFontInitialized = true;
    }

    return &DefaultEmojiFont;
}

FontAsset TestUtils::DefaultLocalFallbackFont;
bool TestUtils::IsDefaultLocalFallbackFontInitialized = false;
core::string TestUtils::DefaultLocalFallbackFamilyName = GetPlatformFallbackFamilyName();

FontAsset* TestUtils::GetDefaultLocalFallbackFont()
{
    if (!IsDefaultLocalFallbackFontInitialized)
    {
        DefaultLocalFallbackFont.faceInfo.familyName = DefaultLocalFallbackFamilyName;
        DefaultLocalFallbackFont.faceInfo.styleName = "Regular";
        DefaultLocalFallbackFont.fontInstanceID = 1;
        IsDefaultLocalFallbackFontInitialized = true;
    }

    return &DefaultLocalFallbackFont;
}

float TestUtils::GetDefaultLineHeight()
{
    TextGenerationSettings tgs = TestUtils::GetDefaultTextGenerationSettings();
    tgs.verticalAlignment = VerticalAlignment::Bottom;

    TextLib textLib;
    textLib.GenerateText(tgs);

    return textLib.m_LineInfos[0].yAdvance;
}

bool TestUtils::IsICUDataLoaded(ICUService &icuService)
{
    return icuService.isICUDataLoaded;
}

bool TestUtils::IsICUDataEmpty(ICUService &icuService)
{
    return icuService.icuData.empty();
}

void TestUtils::TerminateICU(ICUService &icuService)
{
    icuService.TerminateICU();
}

const dynamic_array<TextSegment>* TestUtils::GetTextSegments(TextLib &textLib)
{
    return &textLib.m_TextSegments;
}

const dynamic_array<LineInfo>* TestUtils::GetLineInfos(TextLib &textLib)
{
    return &textLib.m_LineInfos;
}

#endif
